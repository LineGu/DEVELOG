{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nexport default class Editor {\n  constructor() {\n    _defineProperty(this, \"insertionText\", void 0);\n\n    _defineProperty(this, \"stringToInsert\", {\n      h1: '# ',\n      h2: '## ',\n      h3: '### ',\n      bold: '**텍스트**',\n      italic: '_텍스트_',\n      link: '[링크텍스트](링크)',\n      quote: '> ',\n      code: '\\n```\\nCode\\n```\\n',\n      checkbox: '- [ ] ',\n      img: '',\n      table: ''\n    });\n\n    _defineProperty(this, \"insertText\", (text, input, indexForInsertion) => {\n      const frontPart = input.slice(0, indexForInsertion);\n      const backPart = input.slice(indexForInsertion);\n      const updatedText = frontPart + text + backPart;\n      return updatedText;\n    });\n\n    _defineProperty(this, \"findSideEdges\", (input, cursorPosition) => {\n      const currentPoint = cursorPosition[0];\n      const frontPart = input.slice(0, currentPoint);\n      const backPart = input.slice(currentPoint);\n      const frontEdgeIndex = frontPart.lastIndexOf('\\n') + 1;\n      const backLenOfLine = backPart.indexOf('\\n') === -1 ? backPart.length + 1 : backPart.indexOf('\\n') + 1;\n      const backEdgeIndex = frontPart.length + backLenOfLine;\n      return [frontEdgeIndex, backEdgeIndex];\n    });\n  }\n\n  createImgString(url) {\n    this.stringToInsert.img = `\\n![](${url})\\n`;\n  }\n\n  createTableString(tableCount) {\n    const [row, column] = tableCount !== null && tableCount !== void 0 ? tableCount : [-1, -1];\n    const rowText = `|${'    |'.repeat(row)}\\n|${'----|'.repeat(row)}`;\n    const columnText = `${'\\n'}${'|'}${'    |'.repeat(row)}`;\n    this.stringToInsert.table = `\\n\\n${rowText}${columnText.repeat(column - 1)}\\n\\n`;\n  }\n\n}","map":{"version":3,"sources":["/Users/hyungu/Desktop/front-dev/projects/develog/client/src/utils/markdownEditor/Editor.ts"],"names":["Editor","h1","h2","h3","bold","italic","link","quote","code","checkbox","img","table","text","input","indexForInsertion","frontPart","slice","backPart","updatedText","cursorPosition","currentPoint","frontEdgeIndex","lastIndexOf","backLenOfLine","indexOf","length","backEdgeIndex","createImgString","url","stringToInsert","createTableString","tableCount","row","column","rowText","repeat","columnText"],"mappings":";;AAeA,eAAe,MAAeA,MAAf,CAAsB;AAAA;AAAA;;AAAA,4CAGD;AAChCC,MAAAA,EAAE,EAAE,IAD4B;AAEhCC,MAAAA,EAAE,EAAE,KAF4B;AAGhCC,MAAAA,EAAE,EAAE,MAH4B;AAIhCC,MAAAA,IAAI,EAAE,SAJ0B;AAKhCC,MAAAA,MAAM,EAAE,OALwB;AAMhCC,MAAAA,IAAI,EAAE,aAN0B;AAOhCC,MAAAA,KAAK,EAAE,IAPyB;AAQhCC,MAAAA,IAAI,EAAE,oBAR0B;AAShCC,MAAAA,QAAQ,EAAE,QATsB;AAUhCC,MAAAA,GAAG,EAAE,EAV2B;AAWhCC,MAAAA,KAAK,EAAE;AAXyB,KAHC;;AAAA,wCAmBf,CAACC,IAAD,EAAeC,KAAf,EAA8BC,iBAA9B,KAAoE;AACtF,YAAMC,SAAS,GAAGF,KAAK,CAACG,KAAN,CAAY,CAAZ,EAAeF,iBAAf,CAAlB;AACA,YAAMG,QAAQ,GAAGJ,KAAK,CAACG,KAAN,CAAYF,iBAAZ,CAAjB;AACA,YAAMI,WAAW,GAAGH,SAAS,GAAGH,IAAZ,GAAmBK,QAAvC;AACA,aAAOC,WAAP;AACD,KAxBkC;;AAAA,2CA0BZ,CAACL,KAAD,EAAgBM,cAAhB,KAAuD;AAC5E,YAAMC,YAAY,GAAGD,cAAc,CAAC,CAAD,CAAnC;AACA,YAAMJ,SAAS,GAAGF,KAAK,CAACG,KAAN,CAAY,CAAZ,EAAeI,YAAf,CAAlB;AACA,YAAMH,QAAQ,GAAGJ,KAAK,CAACG,KAAN,CAAYI,YAAZ,CAAjB;AACA,YAAMC,cAAc,GAAGN,SAAS,CAACO,WAAV,CAAsB,IAAtB,IAA8B,CAArD;AACA,YAAMC,aAAa,GAAGN,QAAQ,CAACO,OAAT,CAAiB,IAAjB,MAA2B,CAAC,CAA5B,GAAgCP,QAAQ,CAACQ,MAAT,GAAkB,CAAlD,GAAsDR,QAAQ,CAACO,OAAT,CAAiB,IAAjB,IAAyB,CAArG;AACA,YAAME,aAAa,GAAGX,SAAS,CAACU,MAAV,GAAmBF,aAAzC;AAEA,aAAO,CAACF,cAAD,EAAiBK,aAAjB,CAAP;AACD,KAnCkC;AAAA;;AAqC5BC,EAAAA,eAAP,CAAuBC,GAAvB,EAA0C;AACxC,SAAKC,cAAL,CAAoBnB,GAApB,GAA2B,SAAQkB,GAAI,KAAvC;AACD;;AAEME,EAAAA,iBAAP,CAAyBC,UAAzB,EAAqD;AACnD,UAAM,CAACC,GAAD,EAAMC,MAAN,IAAgBF,UAAhB,aAAgBA,UAAhB,cAAgBA,UAAhB,GAA8B,CAAC,CAAC,CAAF,EAAK,CAAC,CAAN,CAApC;AACA,UAAMG,OAAO,GAAI,IAAG,QAAQC,MAAR,CAAeH,GAAf,CAAoB,MAAK,QAAQG,MAAR,CAAeH,GAAf,CAAoB,EAAjE;AACA,UAAMI,UAAU,GAAI,GAAE,IAAK,GAAE,GAAI,GAAE,QAAQD,MAAR,CAAeH,GAAf,CAAoB,EAAvD;AAEA,SAAKH,cAAL,CAAoBlB,KAApB,GAA6B,OAAMuB,OAAQ,GAAEE,UAAU,CAACD,MAAX,CAAkBF,MAAM,GAAG,CAA3B,CAA8B,MAA3E;AACD;;AA/CkC","sourcesContent":["type editType = {\n  [index: string]: string;\n  h1: string;\n  h2: string;\n  h3: string;\n  bold: string;\n  italic: string;\n  link: string;\n  quote: string;\n  code: string;\n  checkbox: string;\n  img: string;\n  table: string;\n};\n\nexport default abstract class Editor {\n  public abstract insertionText: string;\n\n  public stringToInsert: editType = {\n    h1: '# ',\n    h2: '## ',\n    h3: '### ',\n    bold: '**텍스트**',\n    italic: '_텍스트_',\n    link: '[링크텍스트](링크)',\n    quote: '> ',\n    code: '\\n```\\nCode\\n```\\n',\n    checkbox: '- [ ] ',\n    img: '',\n    table: '',\n  };\n\n  public abstract editInput(input: string, cursorPosition: number[]): { updatedText: string; cursorToGo: number[] };\n\n  public insertText = (text: string, input: string, indexForInsertion: number): string => {\n    const frontPart = input.slice(0, indexForInsertion);\n    const backPart = input.slice(indexForInsertion);\n    const updatedText = frontPart + text + backPart;\n    return updatedText;\n  };\n\n  public findSideEdges = (input: string, cursorPosition: number[]): number[] => {\n    const currentPoint = cursorPosition[0];\n    const frontPart = input.slice(0, currentPoint);\n    const backPart = input.slice(currentPoint);\n    const frontEdgeIndex = frontPart.lastIndexOf('\\n') + 1;\n    const backLenOfLine = backPart.indexOf('\\n') === -1 ? backPart.length + 1 : backPart.indexOf('\\n') + 1;\n    const backEdgeIndex = frontPart.length + backLenOfLine;\n\n    return [frontEdgeIndex, backEdgeIndex];\n  };\n\n  public createImgString(url: string): void {\n    this.stringToInsert.img = `\\n![](${url})\\n`;\n  }\n\n  public createTableString(tableCount: number[]): void {\n    const [row, column] = tableCount ?? [-1, -1];\n    const rowText = `|${'    |'.repeat(row)}\\n|${'----|'.repeat(row)}`;\n    const columnText = `${'\\n'}${'|'}${'    |'.repeat(row)}`;\n\n    this.stringToInsert.table = `\\n\\n${rowText}${columnText.repeat(column - 1)}\\n\\n`;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}