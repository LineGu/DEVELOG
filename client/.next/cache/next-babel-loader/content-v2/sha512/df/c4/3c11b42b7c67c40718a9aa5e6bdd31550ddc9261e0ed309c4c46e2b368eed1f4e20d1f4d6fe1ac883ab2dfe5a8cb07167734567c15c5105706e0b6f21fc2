{"ast":null,"code":"import _toConsumableArray from \"/Users/hyungu/Desktop/front-dev/projects/develog/client/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nexport var getLastText = function getLastText(input) {\n  return input.slice(input.length - 1, input.length);\n};\nexport var isEmptyLine = function isEmptyLine(input) {\n  return input === '';\n};\nexport var hideLastSlash = function hideLastSlash(input) {\n  return \"\".concat(input, \"&nbsp;\");\n};\nexport var createTextsByLine = function createTextsByLine(input) {\n  return input.split('\\n');\n};\nexport var applyBlankToMarkdown = function applyBlankToMarkdown(input) {\n  if (isEmptyLine(input)) return \"\\\\\";\n  return input;\n};\nexport var DelBlankAfterLastText = function DelBlankAfterLastText(TextsByLine) {\n  var blankIdxs = [];\n  TextsByLine.forEach(function (text, index) {\n    if (text === '\\\\') blankIdxs.push(index);else blankIdxs = [];\n  });\n\n  var updatedTextsByLine = _toConsumableArray(TextsByLine);\n\n  blankIdxs.forEach(function (idx) {\n    updatedTextsByLine[idx] = '';\n  });\n  return updatedTextsByLine;\n};\n_c = DelBlankAfterLastText;\nexport var DelSlashBeforeText = function DelSlashBeforeText(TextsByLine) {\n  var blankIdxsBeforeText = [];\n  TextsByLine.forEach(function (text, index) {\n    if (text !== '\\\\' && TextsByLine[index - 1] === '\\\\') blankIdxsBeforeText.push(index - 1);\n  });\n\n  var updatedTextsByLine = _toConsumableArray(TextsByLine);\n\n  blankIdxsBeforeText.forEach(function (idx) {\n    updatedTextsByLine[idx] = \"&nbsp;\";\n  });\n  return updatedTextsByLine;\n};\n_c2 = DelSlashBeforeText;\nexport var delBlankInCode = function delBlankInCode(TextsByLine) {\n  var idxsCodeBox = [];\n  var isInCodeBox = false;\n  TextsByLine.forEach(function (text, index) {\n    if (text === '```') isInCodeBox = !isInCodeBox;\n    if ((text === '\\\\' || text === '&nbsp;') && isInCodeBox) idxsCodeBox.push(index);\n  });\n  if (idxsCodeBox.length % 2 !== 0) idxsCodeBox.push(TextsByLine.length - 1);\n\n  var updatedTextsByLine = _toConsumableArray(TextsByLine);\n\n  idxsCodeBox.forEach(function (idx) {\n    updatedTextsByLine[idx] = '';\n  });\n  return updatedTextsByLine;\n};\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"DelBlankAfterLastText\");\n$RefreshReg$(_c2, \"DelSlashBeforeText\");","map":{"version":3,"sources":["/Users/hyungu/Desktop/front-dev/projects/develog/client/src/utils/markdown/markdown.ts"],"names":["getLastText","input","slice","length","isEmptyLine","hideLastSlash","createTextsByLine","split","applyBlankToMarkdown","DelBlankAfterLastText","TextsByLine","blankIdxs","forEach","text","index","push","updatedTextsByLine","idx","DelSlashBeforeText","blankIdxsBeforeText","delBlankInCode","idxsCodeBox","isInCodeBox"],"mappings":"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","sourcesContent":["export const getLastText = (input: string): string => {\n  return input.slice(input.length - 1, input.length);\n};\n\nexport const isEmptyLine = (input: string): boolean => {\n  return input === '';\n};\n\nexport const hideLastSlash = (input: string): string => {\n  return `${input}&nbsp;`;\n};\n\nexport const createTextsByLine = (input: string): string[] => {\n  return input.split('\\n');\n};\n\nexport const applyBlankToMarkdown = (input: string): string => {\n  if (isEmptyLine(input)) return `\\\\`;\n  return input;\n};\n\nexport const DelBlankAfterLastText = (TextsByLine: string[]): string[] => {\n  let blankIdxs: number[] = [];\n\n  TextsByLine.forEach((text, index): void => {\n    if (text === '\\\\') blankIdxs.push(index);\n    else blankIdxs = [];\n  });\n  const updatedTextsByLine = [...TextsByLine];\n  blankIdxs.forEach((idx) => {\n    updatedTextsByLine[idx] = '';\n  });\n  return updatedTextsByLine;\n};\n\nexport const DelSlashBeforeText = (TextsByLine: string[]): string[] => {\n  const blankIdxsBeforeText: number[] = [];\n\n  TextsByLine.forEach((text, index): void => {\n    if (text !== '\\\\' && TextsByLine[index - 1] === '\\\\') blankIdxsBeforeText.push(index - 1);\n  });\n\n  const updatedTextsByLine = [...TextsByLine];\n  blankIdxsBeforeText.forEach((idx) => {\n    updatedTextsByLine[idx] = `&nbsp;`;\n  });\n  return updatedTextsByLine;\n};\n\nexport const delBlankInCode = (TextsByLine: string[]): string[] => {\n  const idxsCodeBox = [];\n  let isInCodeBox = false;\n  TextsByLine.forEach((text, index) => {\n    if (text === '```') isInCodeBox = !isInCodeBox;\n    if ((text === '\\\\' || text === '&nbsp;') && isInCodeBox) idxsCodeBox.push(index);\n  });\n\n  if (idxsCodeBox.length % 2 !== 0) idxsCodeBox.push(TextsByLine.length - 1);\n\n  const updatedTextsByLine = [...TextsByLine];\n  idxsCodeBox.forEach((idx) => {\n    updatedTextsByLine[idx] = '';\n  });\n\n  return updatedTextsByLine;\n};\n"]},"metadata":{},"sourceType":"module"}