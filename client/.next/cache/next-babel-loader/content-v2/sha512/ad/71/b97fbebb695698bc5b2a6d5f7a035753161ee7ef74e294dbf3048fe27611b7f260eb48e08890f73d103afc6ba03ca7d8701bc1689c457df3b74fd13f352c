{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport FADE from '@constants/Fade';\n\nconst fadeText = props => {\n  const {\n    isMounted,\n    setMargin,\n    setOpacity,\n    timer,\n    method\n  } = props;\n  const numListToApply = method === FADE.OUT ? [FADE.MAXIMUM_GAP_BOXES, FADE.NUM_HIDE_TEXT] : [FADE.MINIMUM_GAP_BOXES, FADE.NUM_SHOW_TEXT];\n\n  if (!isMounted) {\n    clearTimeout(timer);\n    return;\n  }\n\n  setMargin(numListToApply[0]);\n  setOpacity(numListToApply[1]);\n};\n\nexport const fadeOutTextBox = props => {\n  const setTimingText = setTimeout(() => {\n    fadeText(_objectSpread(_objectSpread({}, props), {}, {\n      timer: setTimingText,\n      method: FADE.OUT\n    }));\n    const hideText = setInterval(() => {\n      fadeText(_objectSpread(_objectSpread({}, props), {}, {\n        timer: hideText,\n        method: FADE.OUT\n      }));\n    }, FADE.TEXT_PERIOD);\n  }, FADE.REPEAT_START_TIMING);\n};\nexport const fadeInTextBox = props => {\n  const timerToShow = setInterval(() => {\n    fadeText(_objectSpread(_objectSpread({}, props), {}, {\n      timer: timerToShow,\n      method: FADE.IN\n    }));\n  }, FADE.TEXT_PERIOD);\n};","map":{"version":3,"sources":["/Users/hyungu/Desktop/front-dev/projects/develog/client/src/utils/animaiton/fadeText.ts"],"names":["FADE","fadeText","props","isMounted","setMargin","setOpacity","timer","method","numListToApply","OUT","MAXIMUM_GAP_BOXES","NUM_HIDE_TEXT","MINIMUM_GAP_BOXES","NUM_SHOW_TEXT","clearTimeout","fadeOutTextBox","setTimingText","setTimeout","hideText","setInterval","TEXT_PERIOD","REPEAT_START_TIMING","fadeInTextBox","timerToShow","IN"],"mappings":";;;;;;AACA,OAAOA,IAAP,MAAiB,iBAAjB;;AAEA,MAAMC,QAAmB,GAAIC,KAAD,IAAW;AACrC,QAAM;AAAEC,IAAAA,SAAF;AAAaC,IAAAA,SAAb;AAAwBC,IAAAA,UAAxB;AAAoCC,IAAAA,KAApC;AAA2CC,IAAAA;AAA3C,MAAsDL,KAA5D;AACA,QAAMM,cAAc,GAClBD,MAAM,KAAKP,IAAI,CAACS,GAAhB,GAAsB,CAACT,IAAI,CAACU,iBAAN,EAAyBV,IAAI,CAACW,aAA9B,CAAtB,GAAqE,CAACX,IAAI,CAACY,iBAAN,EAAyBZ,IAAI,CAACa,aAA9B,CADvE;;AAEA,MAAI,CAACV,SAAL,EAAgB;AACdW,IAAAA,YAAY,CAACR,KAAD,CAAZ;AACA;AACD;;AACDF,EAAAA,SAAS,CAACI,cAAc,CAAC,CAAD,CAAf,CAAT;AACAH,EAAAA,UAAU,CAACG,cAAc,CAAC,CAAD,CAAf,CAAV;AACD,CAVD;;AAYA,OAAO,MAAMO,cAA8B,GAAIb,KAAD,IAAW;AACvD,QAAMc,aAAa,GAAGC,UAAU,CAAC,MAAM;AACrChB,IAAAA,QAAQ,iCAAMC,KAAN;AAAaI,MAAAA,KAAK,EAAEU,aAApB;AAAmCT,MAAAA,MAAM,EAAEP,IAAI,CAACS;AAAhD,OAAR;AACA,UAAMS,QAAQ,GAAGC,WAAW,CAAC,MAAM;AACjClB,MAAAA,QAAQ,iCAAMC,KAAN;AAAaI,QAAAA,KAAK,EAAEY,QAApB;AAA8BX,QAAAA,MAAM,EAAEP,IAAI,CAACS;AAA3C,SAAR;AACD,KAF2B,EAEzBT,IAAI,CAACoB,WAFoB,CAA5B;AAGD,GAL+B,EAK7BpB,IAAI,CAACqB,mBALwB,CAAhC;AAMD,CAPM;AASP,OAAO,MAAMC,aAA6B,GAAIpB,KAAD,IAAW;AACtD,QAAMqB,WAAW,GAAGJ,WAAW,CAAC,MAAM;AACpClB,IAAAA,QAAQ,iCAAMC,KAAN;AAAaI,MAAAA,KAAK,EAAEiB,WAApB;AAAiChB,MAAAA,MAAM,EAAEP,IAAI,CAACwB;AAA9C,OAAR;AACD,GAF8B,EAE5BxB,IAAI,CAACoB,WAFuB,CAA/B;AAGD,CAJM","sourcesContent":["import { IFadeFunc, IFadeInOutFunc } from '@types';\nimport FADE from '@constants/Fade';\n\nconst fadeText: IFadeFunc = (props) => {\n  const { isMounted, setMargin, setOpacity, timer, method } = props;\n  const numListToApply =\n    method === FADE.OUT ? [FADE.MAXIMUM_GAP_BOXES, FADE.NUM_HIDE_TEXT] : [FADE.MINIMUM_GAP_BOXES, FADE.NUM_SHOW_TEXT];\n  if (!isMounted) {\n    clearTimeout(timer);\n    return;\n  }\n  setMargin(numListToApply[0]);\n  setOpacity(numListToApply[1]);\n};\n\nexport const fadeOutTextBox: IFadeInOutFunc = (props) => {\n  const setTimingText = setTimeout(() => {\n    fadeText({ ...props, timer: setTimingText, method: FADE.OUT });\n    const hideText = setInterval(() => {\n      fadeText({ ...props, timer: hideText, method: FADE.OUT });\n    }, FADE.TEXT_PERIOD);\n  }, FADE.REPEAT_START_TIMING);\n};\n\nexport const fadeInTextBox: IFadeInOutFunc = (props) => {\n  const timerToShow = setInterval(() => {\n    fadeText({ ...props, timer: timerToShow, method: FADE.IN });\n  }, FADE.TEXT_PERIOD);\n};\n"]},"metadata":{},"sourceType":"module"}