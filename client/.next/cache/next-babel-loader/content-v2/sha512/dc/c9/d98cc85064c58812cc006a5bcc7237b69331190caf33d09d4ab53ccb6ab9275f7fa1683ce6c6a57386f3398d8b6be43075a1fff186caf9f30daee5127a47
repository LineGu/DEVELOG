{"ast":null,"code":"export const getLastText = input => {\n  return input.slice(input.length - 1, input.length);\n};\nexport const isEmptyLine = input => {\n  return input === '';\n};\nexport const hideLastSlash = input => {\n  return `${input}&nbsp;`;\n};\nexport const createTextsByLine = input => {\n  return input.split('\\n');\n};\nexport const applyBlankToMarkdown = input => {\n  if (isEmptyLine(input)) return `\\\\`;\n  return input;\n};\nexport const DelBlankAfterLastText = TextsByLine => {\n  let blankIdxs = [];\n  TextsByLine.forEach((text, index) => {\n    if (text === '\\\\') blankIdxs.push(index);else blankIdxs = [];\n  });\n  const updatedTextsByLine = [...TextsByLine];\n  blankIdxs.forEach(idx => {\n    updatedTextsByLine[idx] = '';\n  });\n  return updatedTextsByLine;\n};\nexport const DelSlashBeforeText = TextsByLine => {\n  const blankIdxsBeforeText = [];\n  TextsByLine.forEach((text, index) => {\n    if (text !== '\\\\' && TextsByLine[index - 1] === '\\\\') blankIdxsBeforeText.push(index - 1);\n  });\n  const updatedTextsByLine = [...TextsByLine];\n  blankIdxsBeforeText.forEach(idx => {\n    updatedTextsByLine[idx] = `&nbsp;`;\n  });\n  return updatedTextsByLine;\n};\nexport const delBlankInCode = TextsByLine => {\n  const idxsBlankInCodeBox = [];\n  let isInCodeBox = false;\n  TextsByLine.forEach((text, index) => {\n    if (text.slice(0, 3) === '```') isInCodeBox = !isInCodeBox;\n    if ((text === '\\\\' || text === '&nbsp;') && isInCodeBox) idxsBlankInCodeBox.push(index);\n  });\n  const updatedTextsByLine = [...TextsByLine];\n  idxsBlankInCodeBox.forEach(idx => {\n    updatedTextsByLine[idx] = '';\n  });\n  return updatedTextsByLine;\n};\nexport const delSlashAfterTable = TextsByLine => {\n  const idxsSlashAfterTable = [];\n  TextsByLine.forEach((text, index) => {\n    if (index !== 0 && text.slice(0, 1) !== '|' && getLastText(TextsByLine[index - 1]) === '|') idxsSlashAfterTable.push(index);\n  });\n  let updatedTextsByLine = [...TextsByLine];\n  idxsSlashAfterTable.forEach(idx => {\n    updatedTextsByLine = [...updatedTextsByLine.slice(0, idx), '', ...updatedTextsByLine[idx]];\n  });\n  return updatedTextsByLine;\n};","map":{"version":3,"sources":["/Users/hyungu/Desktop/front-dev/projects/develog/client/src/utils/markdown/markdown.ts"],"names":["getLastText","input","slice","length","isEmptyLine","hideLastSlash","createTextsByLine","split","applyBlankToMarkdown","DelBlankAfterLastText","TextsByLine","blankIdxs","forEach","text","index","push","updatedTextsByLine","idx","DelSlashBeforeText","blankIdxsBeforeText","delBlankInCode","idxsBlankInCodeBox","isInCodeBox","delSlashAfterTable","idxsSlashAfterTable"],"mappings":"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","sourcesContent":["export const getLastText = (input: string): string => {\n  return input.slice(input.length - 1, input.length);\n};\n\nexport const isEmptyLine = (input: string): boolean => {\n  return input === '';\n};\n\nexport const hideLastSlash = (input: string): string => {\n  return `${input}&nbsp;`;\n};\n\nexport const createTextsByLine = (input: string): string[] => {\n  return input.split('\\n');\n};\n\nexport const applyBlankToMarkdown = (input: string): string => {\n  if (isEmptyLine(input)) return `\\\\`;\n  return input;\n};\n\nexport const DelBlankAfterLastText = (TextsByLine: string[]): string[] => {\n  let blankIdxs: number[] = [];\n\n  TextsByLine.forEach((text, index): void => {\n    if (text === '\\\\') blankIdxs.push(index);\n    else blankIdxs = [];\n  });\n  const updatedTextsByLine = [...TextsByLine];\n  blankIdxs.forEach((idx) => {\n    updatedTextsByLine[idx] = '';\n  });\n  return updatedTextsByLine;\n};\n\nexport const DelSlashBeforeText = (TextsByLine: string[]): string[] => {\n  const blankIdxsBeforeText: number[] = [];\n\n  TextsByLine.forEach((text, index): void => {\n    if (text !== '\\\\' && TextsByLine[index - 1] === '\\\\') blankIdxsBeforeText.push(index - 1);\n  });\n\n  const updatedTextsByLine = [...TextsByLine];\n  blankIdxsBeforeText.forEach((idx) => {\n    updatedTextsByLine[idx] = `&nbsp;`;\n  });\n  return updatedTextsByLine;\n};\n\nexport const delBlankInCode = (TextsByLine: string[]): string[] => {\n  const idxsBlankInCodeBox: number[] = [];\n  let isInCodeBox = false;\n  TextsByLine.forEach((text, index) => {\n    if (text.slice(0, 3) === '```') isInCodeBox = !isInCodeBox;\n    if ((text === '\\\\' || text === '&nbsp;') && isInCodeBox) idxsBlankInCodeBox.push(index);\n  });\n\n  const updatedTextsByLine = [...TextsByLine];\n  idxsBlankInCodeBox.forEach((idx) => {\n    updatedTextsByLine[idx] = '';\n  });\n\n  return updatedTextsByLine;\n};\n\nexport const delSlashAfterTable = (TextsByLine: string[]): string[] => {\n  const idxsSlashAfterTable: number[] = [];\n  TextsByLine.forEach((text, index) => {\n    if (index !== 0 && text.slice(0, 1) !== '|' && getLastText(TextsByLine[index - 1]) === '|')\n      idxsSlashAfterTable.push(index);\n  });\n  let updatedTextsByLine = [...TextsByLine];\n  idxsSlashAfterTable.forEach((idx) => {\n    updatedTextsByLine = [...updatedTextsByLine.slice(0, idx), '', ...updatedTextsByLine[idx]];\n  });\n\n  return updatedTextsByLine;\n};\n"]},"metadata":{},"sourceType":"module"}