{"ast":null,"code":"import _toConsumableArray from \"/Users/hyungu/Desktop/front-dev/projects/develog/client/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nvar blankList = ['\\\\', '', '&nbsp;'];\nexport var getLastText = function getLastText(input) {\n  return input.slice(input.length - 1, input.length);\n};\nexport var isEmptyLine = function isEmptyLine(input) {\n  return input === '';\n};\nexport var hideLastSlash = function hideLastSlash(input) {\n  return \"\".concat(input, \"&nbsp;\");\n};\nexport var createTextsByLine = function createTextsByLine(input) {\n  return input.split('\\n');\n};\nexport var applyBlankToMarkdown = function applyBlankToMarkdown(input) {\n  if (isEmptyLine(input)) return \"\\\\\";\n  return input;\n};\nexport var changeText = function changeText(TextsByLine, idxsToChange, textToChange) {\n  var updatedTextsByLine = _toConsumableArray(TextsByLine);\n\n  idxsToChange.forEach(function (idx) {\n    updatedTextsByLine[idx] = textToChange;\n  });\n  return updatedTextsByLine;\n};\nexport var insertText = function insertText(TextsByLine, idxsToChange, textToInsert) {\n  var updatedTextsByLine = _toConsumableArray(TextsByLine);\n\n  idxsToChange.forEach(function (idx) {\n    updatedTextsByLine = [].concat(_toConsumableArray(updatedTextsByLine.slice(0, idx)), [textToInsert], _toConsumableArray(updatedTextsByLine.slice(idx)));\n  });\n  return updatedTextsByLine;\n};\nexport var findLastTextIdx = function findLastTextIdx(TextsByLine) {\n  var textIdx = -1;\n  TextsByLine.forEach(function (text, idx) {\n    if (!blankList.includes(text)) textIdx = idx;\n  });\n  return textIdx;\n};\nexport var isBlankAfterLastText = function isBlankAfterLastText(TextsByLine, idx) {\n  var idxOfLastText = findLastTextIdx(TextsByLine);\n  if (idx > idxOfLastText && blankList.includes(TextsByLine[idx])) return true;\n  return false;\n};\nexport var isBlankBeforeText = function isBlankBeforeText(TextsByLine, idx) {\n  var currentText = TextsByLine[idx];\n  var beforeText = TextsByLine[idx - 1];\n  if (!blankList.includes(currentText) && blankList.includes(beforeText)) return true;\n  return false;\n};\nexport var getBlankIdxsAfterLastText = function getBlankIdxsAfterLastText(TextsByLine) {\n  var blankIdxs = [];\n  TextsByLine.forEach(function (_, index) {\n    if (isBlankAfterLastText(TextsByLine, index)) blankIdxs.push(index);\n  });\n  return blankIdxs;\n};\nexport var getBlankIdxsBeforeText = function getBlankIdxsBeforeText(TextsByLine) {\n  var blankIdxs = [];\n  TextsByLine.forEach(function (_, index) {\n    if (isBlankBeforeText(TextsByLine, index)) blankIdxs.push(index - 1);\n  });\n  console.log(blankIdxs);\n  return blankIdxs;\n};\nexport var getBlankIdxsInCodeBox = function getBlankIdxsInCodeBox(TextsByLine) {\n  var idxsBlankInCodeBox = [];\n  var isInCodeBox = false;\n  TextsByLine.forEach(function (text, index) {\n    if (text.slice(0, 3) === '```') isInCodeBox = !isInCodeBox;\n    if ((text === '\\\\' || text === '&nbsp;') && isInCodeBox) idxsBlankInCodeBox.push(index);\n  });\n  return idxsBlankInCodeBox;\n};\nexport var getBlankIdxsAfterTable = function getBlankIdxsAfterTable(TextsByLine) {\n  var idxsSlashAfterTable = [];\n  TextsByLine.forEach(function (text, index) {\n    if (index !== 0 && text.slice(0, 1) !== '|' && getLastText(TextsByLine[index - 1]) === '|') idxsSlashAfterTable.push(index);\n  });\n  return idxsSlashAfterTable;\n};","map":{"version":3,"sources":["/Users/hyungu/Desktop/front-dev/projects/develog/client/src/utils/markdown/markdown.ts"],"names":["blankList","getLastText","input","slice","length","isEmptyLine","hideLastSlash","createTextsByLine","split","applyBlankToMarkdown","changeText","TextsByLine","idxsToChange","textToChange","updatedTextsByLine","forEach","idx","insertText","textToInsert","findLastTextIdx","textIdx","text","includes","isBlankAfterLastText","idxOfLastText","isBlankBeforeText","currentText","beforeText","getBlankIdxsAfterLastText","blankIdxs","_","index","push","getBlankIdxsBeforeText","console","log","getBlankIdxsInCodeBox","idxsBlankInCodeBox","isInCodeBox","getBlankIdxsAfterTable","idxsSlashAfterTable"],"mappings":"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","sourcesContent":["const blankList = ['\\\\', '', '&nbsp;'];\n\nexport const getLastText = (input: string): string => {\n  return input.slice(input.length - 1, input.length);\n};\n\nexport const isEmptyLine = (input: string): boolean => {\n  return input === '';\n};\n\nexport const hideLastSlash = (input: string): string => {\n  return `${input}&nbsp;`;\n};\n\nexport const createTextsByLine = (input: string): string[] => {\n  return input.split('\\n');\n};\n\nexport const applyBlankToMarkdown = (input: string): string => {\n  if (isEmptyLine(input)) return `\\\\`;\n  return input;\n};\n\nexport const changeText = (TextsByLine: string[], idxsToChange: number[], textToChange: string): string[] => {\n  const updatedTextsByLine = [...TextsByLine];\n  idxsToChange.forEach((idx) => {\n    updatedTextsByLine[idx] = textToChange;\n  });\n\n  return updatedTextsByLine;\n};\n\nexport const insertText = (TextsByLine: string[], idxsToChange: number[], textToInsert: string): string[] => {\n  let updatedTextsByLine = [...TextsByLine];\n  idxsToChange.forEach((idx) => {\n    updatedTextsByLine = [...updatedTextsByLine.slice(0, idx), textToInsert, ...updatedTextsByLine.slice(idx)];\n  });\n\n  return updatedTextsByLine;\n};\n\nexport const findLastTextIdx = (TextsByLine: string[]): number => {\n  let textIdx = -1;\n  TextsByLine.forEach((text, idx) => {\n    if (!blankList.includes(text)) textIdx = idx;\n  });\n  return textIdx;\n};\n\nexport const isBlankAfterLastText = (TextsByLine: string[], idx: number): boolean => {\n  const idxOfLastText = findLastTextIdx(TextsByLine);\n  if (idx > idxOfLastText && blankList.includes(TextsByLine[idx])) return true;\n  return false;\n};\n\nexport const isBlankBeforeText = (TextsByLine: string[], idx: number): boolean => {\n  const currentText = TextsByLine[idx];\n  const beforeText = TextsByLine[idx - 1];\n  if (!blankList.includes(currentText) && blankList.includes(beforeText)) return true;\n  return false;\n};\n\nexport const getBlankIdxsAfterLastText = (TextsByLine: string[]): number[] => {\n  const blankIdxs: number[] = [];\n  TextsByLine.forEach((_, index): void => {\n    if (isBlankAfterLastText(TextsByLine, index)) blankIdxs.push(index);\n  });\n  return blankIdxs;\n};\n\nexport const getBlankIdxsBeforeText = (TextsByLine: string[]): number[] => {\n  const blankIdxs: number[] = [];\n  TextsByLine.forEach((_, index): void => {\n    if (isBlankBeforeText(TextsByLine, index)) blankIdxs.push(index - 1);\n  });\n  console.log(blankIdxs);\n  return blankIdxs;\n};\n\nexport const getBlankIdxsInCodeBox = (TextsByLine: string[]): number[] => {\n  const idxsBlankInCodeBox: number[] = [];\n  let isInCodeBox = false;\n  TextsByLine.forEach((text, index) => {\n    if (text.slice(0, 3) === '```') isInCodeBox = !isInCodeBox;\n    if ((text === '\\\\' || text === '&nbsp;') && isInCodeBox) idxsBlankInCodeBox.push(index);\n  });\n\n  return idxsBlankInCodeBox;\n};\n\nexport const getBlankIdxsAfterTable = (TextsByLine: string[]): number[] => {\n  const idxsSlashAfterTable: number[] = [];\n  TextsByLine.forEach((text, index) => {\n    if (index !== 0 && text.slice(0, 1) !== '|' && getLastText(TextsByLine[index - 1]) === '|')\n      idxsSlashAfterTable.push(index);\n  });\n  return idxsSlashAfterTable;\n};\n"]},"metadata":{},"sourceType":"module"}