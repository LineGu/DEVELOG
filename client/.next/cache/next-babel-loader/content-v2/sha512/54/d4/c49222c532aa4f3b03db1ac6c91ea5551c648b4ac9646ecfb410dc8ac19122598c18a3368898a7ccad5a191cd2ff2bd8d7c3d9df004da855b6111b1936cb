{"ast":null,"code":"import _toConsumableArray from \"/Users/hyungu/Desktop/front-dev/projects/develog/client/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nvar blankList = ['\\\\', '', '&nbsp;'];\nexport var getLastText = function getLastText(input) {\n  return input.slice(input.length - 1, input.length);\n};\nexport var isEmptyLine = function isEmptyLine(input) {\n  return input === '';\n};\nexport var hideLastSlash = function hideLastSlash(input) {\n  return \"\".concat(input, \"&nbsp;\");\n};\nexport var createTextsByLine = function createTextsByLine(input) {\n  return input.split('\\n');\n};\nexport var applyBlankToMarkdown = function applyBlankToMarkdown(input) {\n  if (isEmptyLine(input)) return \"\\\\\";\n  return input;\n};\nexport var changeText = function changeText(TextsByLine, idxsToChange, textToChange) {\n  var updatedTextsByLine = _toConsumableArray(TextsByLine);\n\n  idxsToChange.forEach(function (idx) {\n    updatedTextsByLine[idx] = textToChange;\n  });\n  console.log(updatedTextsByLine);\n  return updatedTextsByLine;\n};\nexport var insertText = function insertText(TextsByLine, idxsToChange, textToInsert) {\n  var updatedTextsByLine = _toConsumableArray(TextsByLine);\n\n  idxsToChange.forEach(function (idx) {\n    updatedTextsByLine = [].concat(_toConsumableArray(updatedTextsByLine.slice(0, idx)), [textToInsert], _toConsumableArray(updatedTextsByLine.slice(idx)));\n  });\n  return updatedTextsByLine;\n};\nexport var findLastTextIdx = function findLastTextIdx(TextsByLine) {\n  var textIdx = -1;\n  TextsByLine.forEach(function (text, idx) {\n    if (!blankList.includes(text)) textIdx = idx;\n  });\n  return textIdx;\n};\nexport var isBlankAfterLastText = function isBlankAfterLastText(TextsByLine, idx) {\n  var idxOfLastText = findLastTextIdx(TextsByLine);\n  if (idx > idxOfLastText && blankList.includes(TextsByLine[idx])) return true;\n  return false;\n};\nexport var isBlankBeforeText = function isBlankBeforeText(TextsByLine, idx) {\n  var currentText = TextsByLine[idx];\n  var beforeText = TextsByLine[idx - 1];\n  if (!blankList.includes(currentText) && blankList.includes(beforeText)) return true;\n  return false;\n};\nexport var getBlankIdxsAfterLastText = function getBlankIdxsAfterLastText(TextsByLine) {\n  var blankIdxs = [];\n  TextsByLine.forEach(function (_, index) {\n    if (isBlankAfterLastText(TextsByLine, index)) blankIdxs.push(index);\n  });\n  return blankIdxs;\n};\nexport var getBlankIdxsBeforeText = function getBlankIdxsBeforeText(TextsByLine) {\n  var blankIdxs = [];\n  TextsByLine.forEach(function (_, index) {\n    if (isBlankBeforeText(TextsByLine, index)) blankIdxs.push(index);\n  });\n  return blankIdxs;\n};\nexport var getBlankIdxsInCodeBox = function getBlankIdxsInCodeBox(TextsByLine) {\n  var idxsBlankInCodeBox = [];\n  var isInCodeBox = false;\n  TextsByLine.forEach(function (text, index) {\n    if (text.slice(0, 3) === '```') isInCodeBox = !isInCodeBox;\n    if ((text === '\\\\' || text === '&nbsp;') && isInCodeBox) idxsBlankInCodeBox.push(index);\n  });\n  return idxsBlankInCodeBox;\n};\nexport var getBlankIdxsAfterTable = function getBlankIdxsAfterTable(TextsByLine) {\n  var idxsSlashAfterTable = [];\n  TextsByLine.forEach(function (text, index) {\n    if (index !== 0 && text.slice(0, 1) !== '|' && getLastText(TextsByLine[index - 1]) === '|') idxsSlashAfterTable.push(index);\n  });\n  return idxsSlashAfterTable;\n};","map":{"version":3,"sources":["/Users/hyungu/Desktop/front-dev/projects/develog/client/src/utils/markdown/markdown.ts"],"names":["blankList","getLastText","input","slice","length","isEmptyLine","hideLastSlash","createTextsByLine","split","applyBlankToMarkdown","changeText","TextsByLine","idxsToChange","textToChange","updatedTextsByLine","forEach","idx","console","log","insertText","textToInsert","findLastTextIdx","textIdx","text","includes","isBlankAfterLastText","idxOfLastText","isBlankBeforeText","currentText","beforeText","getBlankIdxsAfterLastText","blankIdxs","_","index","push","getBlankIdxsBeforeText","getBlankIdxsInCodeBox","idxsBlankInCodeBox","isInCodeBox","getBlankIdxsAfterTable","idxsSlashAfterTable"],"mappings":"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","sourcesContent":["const blankList = ['\\\\', '', '&nbsp;'];\n\nexport const getLastText = (input: string): string => {\n  return input.slice(input.length - 1, input.length);\n};\n\nexport const isEmptyLine = (input: string): boolean => {\n  return input === '';\n};\n\nexport const hideLastSlash = (input: string): string => {\n  return `${input}&nbsp;`;\n};\n\nexport const createTextsByLine = (input: string): string[] => {\n  return input.split('\\n');\n};\n\nexport const applyBlankToMarkdown = (input: string): string => {\n  if (isEmptyLine(input)) return `\\\\`;\n  return input;\n};\n\nexport const changeText = (TextsByLine: string[], idxsToChange: number[], textToChange: string): string[] => {\n  const updatedTextsByLine = [...TextsByLine];\n  idxsToChange.forEach((idx) => {\n    updatedTextsByLine[idx] = textToChange;\n  });\n  console.log(updatedTextsByLine);\n  return updatedTextsByLine;\n};\n\nexport const insertText = (TextsByLine: string[], idxsToChange: number[], textToInsert: string): string[] => {\n  let updatedTextsByLine = [...TextsByLine];\n  idxsToChange.forEach((idx) => {\n    updatedTextsByLine = [...updatedTextsByLine.slice(0, idx), textToInsert, ...updatedTextsByLine.slice(idx)];\n  });\n\n  return updatedTextsByLine;\n};\n\nexport const findLastTextIdx = (TextsByLine: string[]): number => {\n  let textIdx = -1;\n  TextsByLine.forEach((text, idx) => {\n    if (!blankList.includes(text)) textIdx = idx;\n  });\n  return textIdx;\n};\n\nexport const isBlankAfterLastText = (TextsByLine: string[], idx: number): boolean => {\n  const idxOfLastText = findLastTextIdx(TextsByLine);\n  if (idx > idxOfLastText && blankList.includes(TextsByLine[idx])) return true;\n  return false;\n};\n\nexport const isBlankBeforeText = (TextsByLine: string[], idx: number): boolean => {\n  const currentText = TextsByLine[idx];\n  const beforeText = TextsByLine[idx - 1];\n  if (!blankList.includes(currentText) && blankList.includes(beforeText)) return true;\n  return false;\n};\n\nexport const getBlankIdxsAfterLastText = (TextsByLine: string[]): number[] => {\n  const blankIdxs: number[] = [];\n  TextsByLine.forEach((_, index): void => {\n    if (isBlankAfterLastText(TextsByLine, index)) blankIdxs.push(index);\n  });\n  return blankIdxs;\n};\n\nexport const getBlankIdxsBeforeText = (TextsByLine: string[]): number[] => {\n  const blankIdxs: number[] = [];\n  TextsByLine.forEach((_, index): void => {\n    if (isBlankBeforeText(TextsByLine, index)) blankIdxs.push(index);\n  });\n  return blankIdxs;\n};\n\nexport const getBlankIdxsInCodeBox = (TextsByLine: string[]): number[] => {\n  const idxsBlankInCodeBox: number[] = [];\n  let isInCodeBox = false;\n  TextsByLine.forEach((text, index) => {\n    if (text.slice(0, 3) === '```') isInCodeBox = !isInCodeBox;\n    if ((text === '\\\\' || text === '&nbsp;') && isInCodeBox) idxsBlankInCodeBox.push(index);\n  });\n\n  return idxsBlankInCodeBox;\n};\n\nexport const getBlankIdxsAfterTable = (TextsByLine: string[]): number[] => {\n  const idxsSlashAfterTable: number[] = [];\n  TextsByLine.forEach((text, index) => {\n    if (index !== 0 && text.slice(0, 1) !== '|' && getLastText(TextsByLine[index - 1]) === '|')\n      idxsSlashAfterTable.push(index);\n  });\n  return idxsSlashAfterTable;\n};\n"]},"metadata":{},"sourceType":"module"}