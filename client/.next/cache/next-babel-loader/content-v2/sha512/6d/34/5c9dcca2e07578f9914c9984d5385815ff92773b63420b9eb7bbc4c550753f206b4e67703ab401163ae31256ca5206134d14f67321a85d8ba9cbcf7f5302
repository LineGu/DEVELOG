{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport CurrentInsertion from './CurrentInsertion';\nexport default class AbstractTextEditor extends CurrentInsertion {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"pointStartText\", void 0);\n\n    _defineProperty(this, \"pointEndText\", void 0);\n\n    _defineProperty(this, \"onClickEditButton\", ({\n      input,\n      cursorPosition,\n      moveCursor\n    }) => {\n      const currentCursorIndex = cursorPosition[0];\n      const isSelected = cursorPosition[0] !== cursorPosition[1];\n      this.setIndexToInsert(currentCursorIndex);\n      this.setIndexToGo(currentCursorIndex);\n      let updatedInput = input;\n\n      if (isSelected) {\n        updatedInput = this.insertSelectedText({\n          input,\n          cursorPosition,\n          moveCursor\n        });\n      } else {\n        updatedInput = this.insertText(input);\n      }\n\n      this.moveCursorAfterEdit(moveCursor);\n      return updatedInput;\n    });\n\n    _defineProperty(this, \"_isInSameTag\", (input, frontCursor, backCursor) => {\n      return input.slice(frontCursor - this.pointStartText.length, frontCursor).includes(this.pointStartText) && input.slice(backCursor, backCursor + this.pointEndText.length).includes(this.pointEndText);\n    });\n\n    _defineProperty(this, \"_insertTextBetweenIdxs\", (input, frontIdx, backIdx, textToInsert) => {\n      const updatedInput = input.slice(0, frontIdx) + textToInsert + input.slice(backIdx);\n      return updatedInput;\n    });\n\n    _defineProperty(this, \"insertSelectedText\", ({\n      input,\n      cursorPosition,\n      moveCursor\n    }) => {\n      const [frontCursor, backCursor] = cursorPosition;\n      const selectText = input.slice(frontCursor, backCursor);\n      let updatedInput = input;\n\n      if (this._isInSameTag(input, frontCursor, backCursor)) {\n        const sameTagIdxs = [frontCursor - this.pointStartText.length, backCursor + this.pointEndText.length];\n        updatedInput = this._insertTextBetweenIdxs(input, sameTagIdxs[0], sameTagIdxs[1], selectText);\n        this.indexToGo = [sameTagIdxs[0], sameTagIdxs[1]];\n        return updatedInput;\n      }\n\n      const textToInsert = this.pointStartText + selectText + this.pointEndText;\n      updatedInput = this._insertTextBetweenIdxs(input, frontCursor, backCursor, textToInsert);\n      this.indexToGo = [frontCursor + this.pointStartText.length, frontCursor + this.pointStartText.length + selectText.length];\n      return updatedInput;\n    });\n  }\n\n}","map":{"version":3,"sources":["/Users/hyungu/Desktop/front-dev/projects/develog/client/src/markdownController/ToolBarEditors/Abstract/TextEditor.ts"],"names":["CurrentInsertion","AbstractTextEditor","input","cursorPosition","moveCursor","currentCursorIndex","isSelected","setIndexToInsert","setIndexToGo","updatedInput","insertSelectedText","insertText","moveCursorAfterEdit","frontCursor","backCursor","slice","pointStartText","length","includes","pointEndText","frontIdx","backIdx","textToInsert","selectText","_isInSameTag","sameTagIdxs","_insertTextBetweenIdxs","indexToGo"],"mappings":"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","sourcesContent":["import { IOnClickEditButton } from '@types';\nimport CurrentInsertion from './CurrentInsertion';\n\nexport default abstract class AbstractTextEditor extends CurrentInsertion {\n  protected abstract pointStartText: string;\n\n  protected abstract pointEndText: string;\n\n  public onClickEditButton = ({ input, cursorPosition, moveCursor }: IOnClickEditButton): string => {\n    const currentCursorIndex = cursorPosition[0];\n    const isSelected = cursorPosition[0] !== cursorPosition[1];\n    this.setIndexToInsert(currentCursorIndex);\n    this.setIndexToGo(currentCursorIndex);\n    let updatedInput = input;\n    if (isSelected) {\n      updatedInput = this.insertSelectedText({ input, cursorPosition, moveCursor });\n    } else {\n      updatedInput = this.insertText(input);\n    }\n    this.moveCursorAfterEdit(moveCursor);\n    return updatedInput;\n  };\n\n  private _isInSameTag = (input: string, frontCursor: number, backCursor: number): boolean => {\n    return (\n      input.slice(frontCursor - this.pointStartText.length, frontCursor).includes(this.pointStartText) &&\n      input.slice(backCursor, backCursor + this.pointEndText.length).includes(this.pointEndText)\n    );\n  };\n\n  private _insertTextBetweenIdxs = (input: string, frontIdx: number, backIdx: number, textToInsert: string): string => {\n    const updatedInput = input.slice(0, frontIdx) + textToInsert + input.slice(backIdx);\n    return updatedInput;\n  };\n\n  protected insertSelectedText = ({ input, cursorPosition, moveCursor }: IOnClickEditButton): string => {\n    const [frontCursor, backCursor] = cursorPosition;\n    const selectText = input.slice(frontCursor, backCursor);\n\n    let updatedInput = input;\n    if (this._isInSameTag(input, frontCursor, backCursor)) {\n      const sameTagIdxs = [frontCursor - this.pointStartText.length, backCursor + this.pointEndText.length];\n      updatedInput = this._insertTextBetweenIdxs(input, sameTagIdxs[0], sameTagIdxs[1], selectText);\n      this.indexToGo = [sameTagIdxs[0], sameTagIdxs[1]];\n      return updatedInput;\n    }\n    const textToInsert = this.pointStartText + selectText + this.pointEndText;\n    updatedInput = this._insertTextBetweenIdxs(input, frontCursor, backCursor, textToInsert);\n\n    this.indexToGo = [\n      frontCursor + this.pointStartText.length,\n      frontCursor + this.pointStartText.length + selectText.length,\n    ];\n    return updatedInput;\n  };\n}\n"]},"metadata":{},"sourceType":"module"}