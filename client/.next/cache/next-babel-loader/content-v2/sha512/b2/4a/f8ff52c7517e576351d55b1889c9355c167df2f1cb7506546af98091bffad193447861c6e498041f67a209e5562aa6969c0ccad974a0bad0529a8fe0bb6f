{"ast":null,"code":"const findFrontOfLine = (string, cursorPosition) => {\n  let findingIndex = cursorPosition[0];\n  let isFindFront = true;\n\n  while (isFindFront) {\n    if (string[findingIndex - 1] === '\\n') {\n      isFindFront = false;\n      break;\n    }\n\n    if (findingIndex === 0) {\n      break;\n    }\n\n    findingIndex -= 1;\n  }\n\n  return findingIndex;\n};\n\nconst insertTextFront = ({\n  input,\n  positionToInsert,\n  insertText\n}) => {\n  const textToCheckOverlap = input.slice(positionToInsert, positionToInsert + 4);\n  const beforeText = input.slice(0, positionToInsert);\n  let afterText = input.slice(positionToInsert);\n  let textToInsert = insertText;\n\n  if (insertText.includes('#') && textToCheckOverlap.includes('# ')) {\n    const indexOfMarkDownEnd = textToCheckOverlap.indexOf('# ') + 2;\n    afterText = afterText.slice(indexOfMarkDownEnd);\n  }\n\n  if (insertText.includes('>') && textToCheckOverlap.includes('> ')) {\n    const indexOfMarkDownEnd = textToCheckOverlap.indexOf('> ') + 2;\n    textToInsert = '';\n    afterText = afterText.slice(indexOfMarkDownEnd);\n  }\n\n  const newInput = beforeText + textToInsert + afterText;\n  return newInput;\n};\n\nconst insertTextSide = ({\n  input,\n  cursorPosition,\n  insertText\n}) => {\n  const isSelected = cursorPosition[0] !== cursorPosition[1];\n  let textToInsert = insertText;\n\n  if (isSelected) {\n    const [startPosition, endPosition] = cursorPosition;\n    const textSelected = input.slice(startPosition, endPosition);\n\n    switch (textToInsert) {\n      case '**텍스트**':\n        textToInsert = `**${textSelected}**`;\n        break;\n\n      case '_텍스트_':\n        textToInsert = `_${textSelected}_`;\n        break;\n\n      case '[링크텍스트](링크)':\n        textToInsert = `[${textSelected}](링크)`;\n        break;\n\n      default:\n        break;\n    }\n  }\n};\n\nconst insertToFront = ({\n  input,\n  positionToInsert,\n  insertText,\n  setInput\n}) => {\n  const newInput = insertTextFront({\n    input,\n    positionToInsert,\n    insertText\n  });\n  setInput(newInput);\n};\n\nconst editInputText = ({\n  event,\n  input,\n  setInput,\n  cursorPosition\n}) => {\n  const iconClicked = event.currentTarget.className.baseVal;\n  const positionToInsert = findFrontOfLine(input, cursorPosition);\n  let insertText = '';\n\n  switch (iconClicked) {\n    case 'h1':\n      insertText = '# ';\n      insertToFront({\n        input,\n        positionToInsert,\n        insertText,\n        setInput\n      });\n      break;\n\n    case 'h2':\n      insertText = '## ';\n      insertToFront({\n        input,\n        positionToInsert,\n        insertText,\n        setInput\n      });\n      break;\n\n    case 'h3':\n      insertText = '### ';\n      insertToFront({\n        input,\n        positionToInsert,\n        insertText,\n        setInput\n      });\n      break;\n\n    case 'bold':\n      insertText = '**텍스트**';\n      break;\n\n    case 'italic':\n      insertText = '_텍스트_';\n      break;\n\n    case 'link':\n      insertText = '[링크텍스트](링크)';\n      break;\n\n    case 'quote':\n      insertText = '> ';\n      insertToFront({\n        input,\n        positionToInsert,\n        insertText,\n        setInput\n      });\n      break;\n\n    default:\n      break;\n  }\n};\n\nexport default editInputText;","map":{"version":3,"sources":["/Users/hyungu/Desktop/front-dev/projects/develog/client/src/utils/editInputText.ts"],"names":["findFrontOfLine","string","cursorPosition","findingIndex","isFindFront","insertTextFront","input","positionToInsert","insertText","textToCheckOverlap","slice","beforeText","afterText","textToInsert","includes","indexOfMarkDownEnd","indexOf","newInput","insertTextSide","isSelected","startPosition","endPosition","textSelected","insertToFront","setInput","editInputText","event","iconClicked","currentTarget","className","baseVal"],"mappings":"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","sourcesContent":["import { Dispatch, SetStateAction } from 'react';\n\ninterface IEditTextProps {\n  event: React.MouseEvent<SVGElement, MouseEvent>;\n  input: string;\n  setInput: Dispatch<SetStateAction<string>>;\n  cursorPosition: number[];\n}\n\ninterface IInsertFrontProps {\n  input: string;\n  positionToInsert: number;\n  insertText: string;\n}\n\ninterface IInsertSideProps {\n  input: string;\n  cursorPosition: number[];\n  insertText: string;\n}\n\ninterface IInsertControlProps extends IInsertFrontProps {\n  setInput: Dispatch<SetStateAction<string>>;\n}\n\nconst findFrontOfLine = (string: string, cursorPosition: number[]): number => {\n  let findingIndex = cursorPosition[0];\n  let isFindFront = true;\n  while (isFindFront) {\n    if (string[findingIndex - 1] === '\\n') {\n      isFindFront = false;\n      break;\n    }\n    if (findingIndex === 0) {\n      break;\n    }\n    findingIndex -= 1;\n  }\n  return findingIndex;\n};\n\nconst insertTextFront = ({ input, positionToInsert, insertText }: IInsertFrontProps): string => {\n  const textToCheckOverlap = input.slice(positionToInsert, positionToInsert + 4);\n  const beforeText = input.slice(0, positionToInsert);\n\n  let afterText = input.slice(positionToInsert);\n  let textToInsert = insertText;\n\n  if (insertText.includes('#') && textToCheckOverlap.includes('# ')) {\n    const indexOfMarkDownEnd = textToCheckOverlap.indexOf('# ') + 2;\n    afterText = afterText.slice(indexOfMarkDownEnd);\n  }\n  if (insertText.includes('>') && textToCheckOverlap.includes('> ')) {\n    const indexOfMarkDownEnd = textToCheckOverlap.indexOf('> ') + 2;\n    textToInsert = '';\n    afterText = afterText.slice(indexOfMarkDownEnd);\n  }\n  const newInput = beforeText + textToInsert + afterText;\n  return newInput;\n};\n\nconst insertTextSide = ({ input, cursorPosition, insertText }: IInsertSideProps): string => {\n  const isSelected = cursorPosition[0] !== cursorPosition[1];\n  let textToInsert = insertText;\n\n  if (isSelected) {\n    const [startPosition, endPosition] = cursorPosition;\n    const textSelected = input.slice(startPosition, endPosition);\n    switch (textToInsert) {\n      case '**텍스트**':\n        textToInsert = `**${textSelected}**`;\n        break;\n\n      case '_텍스트_':\n        textToInsert = `_${textSelected}_`;\n        break;\n\n      case '[링크텍스트](링크)':\n        textToInsert = `[${textSelected}](링크)`;\n        break;\n\n      default:\n        break;\n    }\n  }\n};\n\nconst insertToFront = ({ input, positionToInsert, insertText, setInput }: IInsertControlProps) => {\n  const newInput = insertTextFront({ input, positionToInsert, insertText });\n  setInput(newInput);\n};\n\nconst editInputText = ({ event, input, setInput, cursorPosition }: IEditTextProps): void => {\n  const iconClicked = event.currentTarget.className.baseVal;\n  const positionToInsert = findFrontOfLine(input, cursorPosition);\n  let insertText = '';\n  switch (iconClicked) {\n    case 'h1':\n      insertText = '# ';\n      insertToFront({ input, positionToInsert, insertText, setInput });\n      break;\n\n    case 'h2':\n      insertText = '## ';\n      insertToFront({ input, positionToInsert, insertText, setInput });\n      break;\n\n    case 'h3':\n      insertText = '### ';\n      insertToFront({ input, positionToInsert, insertText, setInput });\n      break;\n\n    case 'bold':\n      insertText = '**텍스트**';\n      break;\n\n    case 'italic':\n      insertText = '_텍스트_';\n      break;\n\n    case 'link':\n      insertText = '[링크텍스트](링크)';\n      break;\n\n    case 'quote':\n      insertText = '> ';\n      insertToFront({ input, positionToInsert, insertText, setInput });\n      break;\n\n    default:\n      break;\n  }\n};\n\nexport default editInputText;\n"]},"metadata":{},"sourceType":"module"}