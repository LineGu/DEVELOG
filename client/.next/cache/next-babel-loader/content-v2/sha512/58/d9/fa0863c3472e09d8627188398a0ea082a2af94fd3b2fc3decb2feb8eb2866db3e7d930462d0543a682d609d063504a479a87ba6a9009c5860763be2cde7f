{"ast":null,"code":"export const findFrontOfLine = (input, cursorPosition) => {\n  let findingIndex = cursorPosition[0];\n  let isFindFront = true;\n\n  while (isFindFront) {\n    if (input[findingIndex - 1] === '\\n') {\n      isFindFront = false;\n      break;\n    }\n\n    if (findingIndex === 0) {\n      break;\n    }\n\n    findingIndex -= 1;\n  }\n\n  return findingIndex;\n};\n\nconst findLastOfLine = (input, frontIndex) => {\n  let isFindLast = true;\n  let lastIndex = frontIndex;\n  const textTotalLength = input.length;\n\n  while (isFindLast) {\n    if (input[lastIndex] === '\\n') {\n      isFindLast = false;\n      break;\n    }\n\n    if (lastIndex === textTotalLength) {\n      isFindLast = false;\n      break;\n    }\n\n    lastIndex += 1;\n  }\n\n  return lastIndex;\n};\n\nconst insertTextFront = ({\n  input,\n  cursorPosition,\n  insertText,\n  setInput\n}) => {\n  const positionToInsert = findFrontOfLine(input, cursorPosition);\n  const textToCheckOverlap = input.slice(positionToInsert, positionToInsert + 4);\n  const beforeText = input.slice(0, positionToInsert);\n  let afterText = input.slice(positionToInsert);\n  let textToInsert = insertText;\n\n  if (insertText.includes('#') && textToCheckOverlap.includes('# ')) {\n    const indexOfMarkDownEnd = textToCheckOverlap.indexOf('# ') + 2;\n    afterText = afterText.slice(indexOfMarkDownEnd);\n  }\n\n  if (insertText.includes('>') && textToCheckOverlap.includes('> ')) {\n    const indexOfMarkDownEnd = textToCheckOverlap.indexOf('> ') + 2;\n    textToInsert = '';\n    afterText = afterText.slice(indexOfMarkDownEnd);\n  }\n\n  if (insertText.includes('- [ ]') && textToCheckOverlap.includes('- [ ')) {\n    textToInsert = '';\n    afterText = afterText.slice(6);\n  }\n\n  const newInput = beforeText + textToInsert + afterText;\n  const lastIndexOfLine = findLastOfLine(newInput, positionToInsert);\n  setInput(newInput);\n  return [lastIndexOfLine, lastIndexOfLine];\n};\n\nconst insertTextSide = ({\n  input,\n  cursorPosition,\n  insertText,\n  setInput\n}) => {\n  const isSelected = cursorPosition[0] !== cursorPosition[1];\n  let textToInsert = insertText;\n  let cursorPositionToGo = [0, 0];\n\n  if (isSelected) {\n    const [startPosition, endPosition] = cursorPosition;\n    let textSelected = input.slice(startPosition, endPosition);\n    let beforeText = input.slice(0, startPosition);\n    let afterText = input.slice(endPosition);\n\n    switch (textToInsert) {\n      case '**텍스트**':\n        if (beforeText.slice(-2) === '**' && afterText.slice(0, 2) === '**') {\n          beforeText = beforeText.slice(0, -2);\n          afterText = afterText.slice(2);\n          textToInsert = textSelected;\n          cursorPositionToGo = [startPosition - 2, endPosition - 2];\n          break;\n        }\n\n        if (textSelected.slice(0, 2) === '**' && textSelected.slice(-2) === '**') {\n          textToInsert = textSelected.slice(2, -2);\n          cursorPositionToGo = [startPosition, endPosition - 4];\n          break;\n        }\n\n        textToInsert = `**${textSelected}**`;\n        cursorPositionToGo = [startPosition, endPosition + 4];\n        break;\n\n      case '_텍스트_':\n        if (beforeText.slice(-1) === '_' && afterText.slice(0, 1) === '_') {\n          beforeText = beforeText.slice(0, -1);\n          afterText = afterText.slice(1);\n          textToInsert = textSelected;\n          cursorPositionToGo = [startPosition - 1, endPosition - 1];\n          break;\n        }\n\n        if (isSelected && textSelected.slice(0, 1) === '_' && textSelected.slice(-1) === '_') {\n          textSelected = textSelected.slice(1, -1);\n          textToInsert = textSelected;\n          cursorPositionToGo = [startPosition, endPosition - 2];\n          break;\n        }\n\n        textToInsert = `_${textSelected}_`;\n        cursorPositionToGo = [startPosition, endPosition + 2];\n        break;\n\n      case '[링크텍스트](링크)':\n        textToInsert = `[${textSelected}](링크)`;\n        cursorPositionToGo = [endPosition + 3, endPosition + 5];\n        break;\n\n      default:\n        break;\n    }\n\n    const newInput = beforeText + textToInsert + afterText;\n    setInput(newInput);\n    return cursorPositionToGo;\n  }\n\n  const positionToInsert = cursorPosition[0];\n  const beforeText = input.slice(0, positionToInsert);\n  const afterText = input.slice(positionToInsert);\n  const newInput = beforeText + textToInsert + afterText;\n\n  switch (textToInsert) {\n    case '**텍스트**':\n      cursorPositionToGo = [positionToInsert + 2, positionToInsert + 5];\n      break;\n\n    case '_텍스트_':\n      cursorPositionToGo = [positionToInsert + 1, positionToInsert + 4];\n      break;\n\n    case '[링크텍스트](링크)':\n      cursorPositionToGo = [positionToInsert + 1, positionToInsert + 6];\n      break;\n\n    case '![]()':\n      cursorPositionToGo = [positionToInsert + 5, positionToInsert + 5];\n      break;\n\n    default:\n      break;\n  }\n\n  setInput(newInput);\n  return cursorPositionToGo;\n};\n\nconst insertTable = ({\n  input,\n  cursorPosition,\n  insertText,\n  setInput,\n  iconClicked\n}) => {\n  const isSelected = cursorPosition[0] !== cursorPosition[1];\n  const [startPosition, endPosition] = cursorPosition;\n  const textSelected = input.slice(startPosition, endPosition);\n  let cursorPositionToGo = [0, 0];\n\n  switch (iconClicked) {\n    case 'table':\n      setInput(input.slice(0, cursorPosition[1]) + insertText + input.slice(cursorPosition[1]));\n      cursorPositionToGo = [cursorPosition[1] + 1, cursorPosition[1] + 1];\n      break;\n\n    case 'code':\n      if (isSelected) {\n        setInput(`${input.slice(0, cursorPosition[0])}\\n\\`\\`\\`\\n${textSelected}\\n\\`\\`\\`\\n${input.slice(cursorPosition[1])}`);\n        cursorPositionToGo = [cursorPosition[0] + 4 + textSelected.length, cursorPosition[0] + 4 + textSelected.length];\n        break;\n      }\n\n      setInput(input.slice(0, cursorPosition[0]) + insertText + input.slice(cursorPosition[0]));\n      cursorPositionToGo = [cursorPosition[0] + 5, cursorPosition[0] + 9];\n      break;\n\n    default:\n      break;\n  }\n\n  return cursorPositionToGo;\n};\n\nconst editInputText = ({\n  event,\n  input,\n  setInput,\n  cursorPosition\n}) => {\n  const iconClicked = event.currentTarget.className.baseVal;\n  console.log(iconClicked);\n  let cursorToGo = [0, 0];\n  let insertText = '';\n\n  switch (iconClicked) {\n    case 'h1':\n      insertText = '# ';\n      cursorToGo = insertTextFront({\n        input,\n        cursorPosition,\n        insertText,\n        setInput,\n        iconClicked\n      });\n      break;\n\n    case 'h2':\n      insertText = '## ';\n      cursorToGo = insertTextFront({\n        input,\n        cursorPosition,\n        insertText,\n        setInput,\n        iconClicked\n      });\n      break;\n\n    case 'h3':\n      insertText = '### ';\n      cursorToGo = insertTextFront({\n        input,\n        cursorPosition,\n        insertText,\n        setInput,\n        iconClicked\n      });\n      break;\n\n    case 'bold':\n      insertText = '**텍스트**';\n      cursorToGo = insertTextSide({\n        input,\n        cursorPosition,\n        insertText,\n        setInput,\n        iconClicked\n      });\n      break;\n\n    case 'italic':\n      insertText = '_텍스트_';\n      cursorToGo = insertTextSide({\n        input,\n        cursorPosition,\n        insertText,\n        setInput,\n        iconClicked\n      });\n      break;\n\n    case 'link':\n      insertText = '[링크텍스트](링크)';\n      cursorToGo = insertTextSide({\n        input,\n        cursorPosition,\n        insertText,\n        setInput,\n        iconClicked\n      });\n      break;\n\n    case 'img':\n      insertText = '![]()';\n      cursorToGo = insertTextSide({\n        input,\n        cursorPosition,\n        insertText,\n        setInput,\n        iconClicked\n      });\n      break;\n\n    case 'quote':\n      insertText = '> ';\n      cursorToGo = insertTextFront({\n        input,\n        cursorPosition,\n        insertText,\n        setInput,\n        iconClicked\n      });\n      break;\n\n    case 'table':\n      insertText = '\\n\\n|    |    |    |\\n|----|----|----|\\n|    |    |    |\\n\\n';\n      cursorToGo = insertTable({\n        input,\n        cursorPosition,\n        insertText,\n        setInput,\n        iconClicked\n      });\n      break;\n\n    case 'code':\n      insertText = '\\n```\\nCode\\n```\\n';\n      cursorToGo = insertTable({\n        input,\n        cursorPosition,\n        insertText,\n        setInput,\n        iconClicked\n      });\n      break;\n\n    case 'checkbox':\n      insertText = '- [ ] ';\n      cursorToGo = insertTextFront({\n        input,\n        cursorPosition,\n        insertText,\n        setInput,\n        iconClicked\n      });\n      break;\n\n    default:\n      break;\n  }\n\n  return cursorToGo;\n};\n\nexport default editInputText;","map":{"version":3,"sources":["/Users/hyungu/Desktop/front-dev/projects/develog/client/src/utils/editInputText.ts"],"names":["findFrontOfLine","input","cursorPosition","findingIndex","isFindFront","findLastOfLine","frontIndex","isFindLast","lastIndex","textTotalLength","length","insertTextFront","insertText","setInput","positionToInsert","textToCheckOverlap","slice","beforeText","afterText","textToInsert","includes","indexOfMarkDownEnd","indexOf","newInput","lastIndexOfLine","insertTextSide","isSelected","cursorPositionToGo","startPosition","endPosition","textSelected","insertTable","iconClicked","editInputText","event","currentTarget","className","baseVal","console","log","cursorToGo"],"mappings":"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","sourcesContent":["import { Dispatch, SetStateAction } from 'react';\n\ninterface IEditTextProps {\n  event: React.MouseEvent<SVGElement, MouseEvent>;\n  input: string;\n  setInput: Dispatch<SetStateAction<string>>;\n  cursorPosition: number[];\n}\n\ninterface IInsertFrontProps {\n  input: string;\n  cursorPosition: number[];\n  insertText: string;\n  setInput: Dispatch<SetStateAction<string>>;\n  iconClicked: string;\n}\n\ninterface IInsertSideProps {\n  input: string;\n  cursorPosition: number[];\n  insertText: string;\n  setInput: Dispatch<SetStateAction<string>>;\n  iconClicked: string;\n}\n\nexport const findFrontOfLine = (input: string, cursorPosition: number[]): number => {\n  let findingIndex = cursorPosition[0];\n  let isFindFront = true;\n  while (isFindFront) {\n    if (input[findingIndex - 1] === '\\n') {\n      isFindFront = false;\n      break;\n    }\n    if (findingIndex === 0) {\n      break;\n    }\n    findingIndex -= 1;\n  }\n  return findingIndex;\n};\n\nconst findLastOfLine = (input: string, frontIndex: number): number => {\n  let isFindLast = true;\n  let lastIndex = frontIndex;\n  const textTotalLength = input.length;\n\n  while (isFindLast) {\n    if (input[lastIndex] === '\\n') {\n      isFindLast = false;\n      break;\n    }\n    if (lastIndex === textTotalLength) {\n      isFindLast = false;\n      break;\n    }\n    lastIndex += 1;\n  }\n  return lastIndex;\n};\n\nconst insertTextFront = ({ input, cursorPosition, insertText, setInput }: IInsertFrontProps): number[] => {\n  const positionToInsert = findFrontOfLine(input, cursorPosition);\n\n  const textToCheckOverlap = input.slice(positionToInsert, positionToInsert + 4);\n  const beforeText = input.slice(0, positionToInsert);\n\n  let afterText = input.slice(positionToInsert);\n  let textToInsert = insertText;\n\n  if (insertText.includes('#') && textToCheckOverlap.includes('# ')) {\n    const indexOfMarkDownEnd = textToCheckOverlap.indexOf('# ') + 2;\n    afterText = afterText.slice(indexOfMarkDownEnd);\n  }\n  if (insertText.includes('>') && textToCheckOverlap.includes('> ')) {\n    const indexOfMarkDownEnd = textToCheckOverlap.indexOf('> ') + 2;\n    textToInsert = '';\n    afterText = afterText.slice(indexOfMarkDownEnd);\n  }\n\n  if (insertText.includes('- [ ]') && textToCheckOverlap.includes('- [ ')) {\n    textToInsert = '';\n    afterText = afterText.slice(6);\n  }\n\n  const newInput = beforeText + textToInsert + afterText;\n  const lastIndexOfLine = findLastOfLine(newInput, positionToInsert);\n  setInput(newInput);\n  return [lastIndexOfLine, lastIndexOfLine];\n};\n\nconst insertTextSide = ({ input, cursorPosition, insertText, setInput }: IInsertSideProps): number[] => {\n  const isSelected = cursorPosition[0] !== cursorPosition[1];\n  let textToInsert = insertText;\n  let cursorPositionToGo = [0, 0];\n\n  if (isSelected) {\n    const [startPosition, endPosition] = cursorPosition;\n    let textSelected = input.slice(startPosition, endPosition);\n    let beforeText = input.slice(0, startPosition);\n    let afterText = input.slice(endPosition);\n\n    switch (textToInsert) {\n      case '**텍스트**':\n        if (beforeText.slice(-2) === '**' && afterText.slice(0, 2) === '**') {\n          beforeText = beforeText.slice(0, -2);\n          afterText = afterText.slice(2);\n          textToInsert = textSelected;\n          cursorPositionToGo = [startPosition - 2, endPosition - 2];\n          break;\n        }\n        if (textSelected.slice(0, 2) === '**' && textSelected.slice(-2) === '**') {\n          textToInsert = textSelected.slice(2, -2);\n          cursorPositionToGo = [startPosition, endPosition - 4];\n          break;\n        }\n        textToInsert = `**${textSelected}**`;\n        cursorPositionToGo = [startPosition, endPosition + 4];\n        break;\n\n      case '_텍스트_':\n        if (beforeText.slice(-1) === '_' && afterText.slice(0, 1) === '_') {\n          beforeText = beforeText.slice(0, -1);\n          afterText = afterText.slice(1);\n          textToInsert = textSelected;\n          cursorPositionToGo = [startPosition - 1, endPosition - 1];\n          break;\n        }\n        if (isSelected && textSelected.slice(0, 1) === '_' && textSelected.slice(-1) === '_') {\n          textSelected = textSelected.slice(1, -1);\n          textToInsert = textSelected;\n          cursorPositionToGo = [startPosition, endPosition - 2];\n          break;\n        }\n        textToInsert = `_${textSelected}_`;\n        cursorPositionToGo = [startPosition, endPosition + 2];\n        break;\n\n      case '[링크텍스트](링크)':\n        textToInsert = `[${textSelected}](링크)`;\n        cursorPositionToGo = [endPosition + 3, endPosition + 5];\n        break;\n\n      default:\n        break;\n    }\n    const newInput = beforeText + textToInsert + afterText;\n    setInput(newInput);\n    return cursorPositionToGo;\n  }\n\n  const positionToInsert = cursorPosition[0];\n  const beforeText = input.slice(0, positionToInsert);\n  const afterText = input.slice(positionToInsert);\n  const newInput = beforeText + textToInsert + afterText;\n  switch (textToInsert) {\n    case '**텍스트**':\n      cursorPositionToGo = [positionToInsert + 2, positionToInsert + 5];\n      break;\n    case '_텍스트_':\n      cursorPositionToGo = [positionToInsert + 1, positionToInsert + 4];\n      break;\n    case '[링크텍스트](링크)':\n      cursorPositionToGo = [positionToInsert + 1, positionToInsert + 6];\n      break;\n    case '![]()':\n      cursorPositionToGo = [positionToInsert + 5, positionToInsert + 5];\n      break;\n    default:\n      break;\n  }\n  setInput(newInput);\n  return cursorPositionToGo;\n};\n\nconst insertTable = ({ input, cursorPosition, insertText, setInput, iconClicked }: IInsertSideProps) => {\n  const isSelected = cursorPosition[0] !== cursorPosition[1];\n  const [startPosition, endPosition] = cursorPosition;\n  const textSelected = input.slice(startPosition, endPosition);\n\n  let cursorPositionToGo = [0, 0];\n  switch (iconClicked) {\n    case 'table':\n      setInput(input.slice(0, cursorPosition[1]) + insertText + input.slice(cursorPosition[1]));\n      cursorPositionToGo = [cursorPosition[1] + 1, cursorPosition[1] + 1];\n      break;\n\n    case 'code':\n      if (isSelected) {\n        setInput(\n          `${input.slice(0, cursorPosition[0])}\\n\\`\\`\\`\\n${textSelected}\\n\\`\\`\\`\\n${input.slice(cursorPosition[1])}`,\n        );\n        cursorPositionToGo = [cursorPosition[0] + 4 + textSelected.length, cursorPosition[0] + 4 + textSelected.length];\n        break;\n      }\n      setInput(input.slice(0, cursorPosition[0]) + insertText + input.slice(cursorPosition[0]));\n      cursorPositionToGo = [cursorPosition[0] + 5, cursorPosition[0] + 9];\n      break;\n\n    default:\n      break;\n  }\n\n  return cursorPositionToGo;\n};\n\nconst editInputText = ({ event, input, setInput, cursorPosition }: IEditTextProps): number[] => {\n  const iconClicked = event.currentTarget.className.baseVal;\n  console.log(iconClicked);\n  let cursorToGo: number[] = [0, 0];\n\n  let insertText = '';\n  switch (iconClicked) {\n    case 'h1':\n      insertText = '# ';\n      cursorToGo = insertTextFront({ input, cursorPosition, insertText, setInput, iconClicked });\n      break;\n\n    case 'h2':\n      insertText = '## ';\n      cursorToGo = insertTextFront({ input, cursorPosition, insertText, setInput, iconClicked });\n      break;\n\n    case 'h3':\n      insertText = '### ';\n      cursorToGo = insertTextFront({ input, cursorPosition, insertText, setInput, iconClicked });\n      break;\n\n    case 'bold':\n      insertText = '**텍스트**';\n      cursorToGo = insertTextSide({ input, cursorPosition, insertText, setInput, iconClicked });\n      break;\n\n    case 'italic':\n      insertText = '_텍스트_';\n      cursorToGo = insertTextSide({ input, cursorPosition, insertText, setInput, iconClicked });\n      break;\n\n    case 'link':\n      insertText = '[링크텍스트](링크)';\n      cursorToGo = insertTextSide({ input, cursorPosition, insertText, setInput, iconClicked });\n      break;\n\n    case 'img':\n      insertText = '![]()';\n      cursorToGo = insertTextSide({ input, cursorPosition, insertText, setInput, iconClicked });\n      break;\n\n    case 'quote':\n      insertText = '> ';\n      cursorToGo = insertTextFront({ input, cursorPosition, insertText, setInput, iconClicked });\n      break;\n\n    case 'table':\n      insertText = '\\n\\n|    |    |    |\\n|----|----|----|\\n|    |    |    |\\n\\n';\n      cursorToGo = insertTable({ input, cursorPosition, insertText, setInput, iconClicked });\n      break;\n\n    case 'code':\n      insertText = '\\n```\\nCode\\n```\\n';\n      cursorToGo = insertTable({ input, cursorPosition, insertText, setInput, iconClicked });\n      break;\n\n    case 'checkbox':\n      insertText = '- [ ] ';\n      cursorToGo = insertTextFront({ input, cursorPosition, insertText, setInput, iconClicked });\n      break;\n\n    default:\n      break;\n  }\n  return cursorToGo;\n};\n\nexport default editInputText;\n"]},"metadata":{},"sourceType":"module"}