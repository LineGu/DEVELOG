{"ast":null,"code":"const blankList = ['\\\\', '', '&nbsp;'];\nexport const getLastText = input => {\n  return input.slice(input.length - 1, input.length);\n};\nexport const isEmptyLine = input => {\n  return input === '';\n};\nexport const hideLastSlash = input => {\n  return `${input}&nbsp;`;\n};\nexport const createTextsByLine = input => {\n  return input.split('\\n');\n};\nexport const applyBlankToMarkdown = input => {\n  if (isEmptyLine(input)) return `\\\\`;\n  return input;\n};\nexport const changeText = (TextsByLine, idxsToChange, textToChange) => {\n  const updatedTextsByLine = [...TextsByLine];\n  idxsToChange.forEach(idx => {\n    updatedTextsByLine[idx] = textToChange;\n  });\n  return updatedTextsByLine;\n};\nexport const insertText = (TextsByLine, idxsToChange, textToInsert) => {\n  let updatedTextsByLine = [...TextsByLine];\n  idxsToChange.forEach(idx => {\n    updatedTextsByLine = [...updatedTextsByLine.slice(0, idx), textToInsert, ...updatedTextsByLine.slice(idx)];\n  });\n  return updatedTextsByLine;\n};\nexport const findLastTextIdx = TextsByLine => {\n  let textIdx = -1;\n  TextsByLine.forEach((text, idx) => {\n    if (!blankList.includes(text)) textIdx = idx;\n  });\n  return textIdx;\n};\nexport const isBlankAfterLastText = (TextsByLine, idx) => {\n  const idxOfLastText = findLastTextIdx(TextsByLine);\n  if (idx > idxOfLastText && blankList.includes(TextsByLine[idx])) return true;\n  return false;\n};\nexport const isBlankBeforeText = (TextsByLine, idx) => {\n  const currentText = TextsByLine[idx];\n  const beforeText = TextsByLine[idx - 1];\n  if (!blankList.includes(currentText) && blankList.includes(beforeText)) return true;\n  return false;\n};\nexport const getBlankIdxsAfterLastText = TextsByLine => {\n  const blankIdxs = [];\n  TextsByLine.forEach((_, index) => {\n    if (isBlankAfterLastText(TextsByLine, index)) blankIdxs.push(index);\n  });\n  return blankIdxs;\n};\nexport const getBlankIdxsBeforeText = TextsByLine => {\n  const blankIdxs = [];\n  TextsByLine.forEach((_, index) => {\n    if (isBlankBeforeText(TextsByLine, index)) blankIdxs.push(index - 1);\n  });\n  return blankIdxs;\n};\nexport const getBlankIdxsInCodeBox = TextsByLine => {\n  const idxsBlankInCodeBox = [];\n  let isInCodeBox = false;\n  TextsByLine.forEach((text, index) => {\n    if (text.slice(0, 3) === '```') isInCodeBox = !isInCodeBox;\n    if ((text === '\\\\' || text === '&nbsp;') && isInCodeBox) idxsBlankInCodeBox.push(index);\n  });\n  return idxsBlankInCodeBox;\n};\nexport const getBlankIdxsAfterTable = TextsByLine => {\n  const idxsSlashAfterTable = [];\n  TextsByLine.forEach((text, index) => {\n    if (index !== 0 && text.slice(0, 1) !== '|' && getLastText(TextsByLine[index - 1]) === '|') idxsSlashAfterTable.push(index);\n  });\n  return idxsSlashAfterTable;\n};","map":{"version":3,"sources":["/Users/hyungu/Desktop/front-dev/projects/develog/client/src/utils/markdown/markdown.ts"],"names":["blankList","getLastText","input","slice","length","isEmptyLine","hideLastSlash","createTextsByLine","split","applyBlankToMarkdown","changeText","TextsByLine","idxsToChange","textToChange","updatedTextsByLine","forEach","idx","insertText","textToInsert","findLastTextIdx","textIdx","text","includes","isBlankAfterLastText","idxOfLastText","isBlankBeforeText","currentText","beforeText","getBlankIdxsAfterLastText","blankIdxs","_","index","push","getBlankIdxsBeforeText","getBlankIdxsInCodeBox","idxsBlankInCodeBox","isInCodeBox","getBlankIdxsAfterTable","idxsSlashAfterTable"],"mappings":"AAAA,MAAMA,SAAS,GAAG,CAAC,IAAD,EAAO,EAAP,EAAW,QAAX,CAAlB;AAEA,OAAO,MAAMC,WAAW,GAAIC,KAAD,IAA2B;AACpD,SAAOA,KAAK,CAACC,KAAN,CAAYD,KAAK,CAACE,MAAN,GAAe,CAA3B,EAA8BF,KAAK,CAACE,MAApC,CAAP;AACD,CAFM;AAIP,OAAO,MAAMC,WAAW,GAAIH,KAAD,IAA4B;AACrD,SAAOA,KAAK,KAAK,EAAjB;AACD,CAFM;AAIP,OAAO,MAAMI,aAAa,GAAIJ,KAAD,IAA2B;AACtD,SAAQ,GAAEA,KAAM,QAAhB;AACD,CAFM;AAIP,OAAO,MAAMK,iBAAiB,GAAIL,KAAD,IAA6B;AAC5D,SAAOA,KAAK,CAACM,KAAN,CAAY,IAAZ,CAAP;AACD,CAFM;AAIP,OAAO,MAAMC,oBAAoB,GAAIP,KAAD,IAA2B;AAC7D,MAAIG,WAAW,CAACH,KAAD,CAAf,EAAwB,OAAQ,IAAR;AACxB,SAAOA,KAAP;AACD,CAHM;AAKP,OAAO,MAAMQ,UAAU,GAAG,CAACC,WAAD,EAAwBC,YAAxB,EAAgDC,YAAhD,KAAmF;AAC3G,QAAMC,kBAAkB,GAAG,CAAC,GAAGH,WAAJ,CAA3B;AACAC,EAAAA,YAAY,CAACG,OAAb,CAAsBC,GAAD,IAAS;AAC5BF,IAAAA,kBAAkB,CAACE,GAAD,CAAlB,GAA0BH,YAA1B;AACD,GAFD;AAIA,SAAOC,kBAAP;AACD,CAPM;AASP,OAAO,MAAMG,UAAU,GAAG,CAACN,WAAD,EAAwBC,YAAxB,EAAgDM,YAAhD,KAAmF;AAC3G,MAAIJ,kBAAkB,GAAG,CAAC,GAAGH,WAAJ,CAAzB;AACAC,EAAAA,YAAY,CAACG,OAAb,CAAsBC,GAAD,IAAS;AAC5BF,IAAAA,kBAAkB,GAAG,CAAC,GAAGA,kBAAkB,CAACX,KAAnB,CAAyB,CAAzB,EAA4Ba,GAA5B,CAAJ,EAAsCE,YAAtC,EAAoD,GAAGJ,kBAAkB,CAACX,KAAnB,CAAyBa,GAAzB,CAAvD,CAArB;AACD,GAFD;AAIA,SAAOF,kBAAP;AACD,CAPM;AASP,OAAO,MAAMK,eAAe,GAAIR,WAAD,IAAmC;AAChE,MAAIS,OAAO,GAAG,CAAC,CAAf;AACAT,EAAAA,WAAW,CAACI,OAAZ,CAAoB,CAACM,IAAD,EAAOL,GAAP,KAAe;AACjC,QAAI,CAAChB,SAAS,CAACsB,QAAV,CAAmBD,IAAnB,CAAL,EAA+BD,OAAO,GAAGJ,GAAV;AAChC,GAFD;AAGA,SAAOI,OAAP;AACD,CANM;AAQP,OAAO,MAAMG,oBAAoB,GAAG,CAACZ,WAAD,EAAwBK,GAAxB,KAAiD;AACnF,QAAMQ,aAAa,GAAGL,eAAe,CAACR,WAAD,CAArC;AACA,MAAIK,GAAG,GAAGQ,aAAN,IAAuBxB,SAAS,CAACsB,QAAV,CAAmBX,WAAW,CAACK,GAAD,CAA9B,CAA3B,EAAiE,OAAO,IAAP;AACjE,SAAO,KAAP;AACD,CAJM;AAMP,OAAO,MAAMS,iBAAiB,GAAG,CAACd,WAAD,EAAwBK,GAAxB,KAAiD;AAChF,QAAMU,WAAW,GAAGf,WAAW,CAACK,GAAD,CAA/B;AACA,QAAMW,UAAU,GAAGhB,WAAW,CAACK,GAAG,GAAG,CAAP,CAA9B;AACA,MAAI,CAAChB,SAAS,CAACsB,QAAV,CAAmBI,WAAnB,CAAD,IAAoC1B,SAAS,CAACsB,QAAV,CAAmBK,UAAnB,CAAxC,EAAwE,OAAO,IAAP;AACxE,SAAO,KAAP;AACD,CALM;AAOP,OAAO,MAAMC,yBAAyB,GAAIjB,WAAD,IAAqC;AAC5E,QAAMkB,SAAmB,GAAG,EAA5B;AACAlB,EAAAA,WAAW,CAACI,OAAZ,CAAoB,CAACe,CAAD,EAAIC,KAAJ,KAAoB;AACtC,QAAIR,oBAAoB,CAACZ,WAAD,EAAcoB,KAAd,CAAxB,EAA8CF,SAAS,CAACG,IAAV,CAAeD,KAAf;AAC/C,GAFD;AAGA,SAAOF,SAAP;AACD,CANM;AAQP,OAAO,MAAMI,sBAAsB,GAAItB,WAAD,IAAqC;AACzE,QAAMkB,SAAmB,GAAG,EAA5B;AACAlB,EAAAA,WAAW,CAACI,OAAZ,CAAoB,CAACe,CAAD,EAAIC,KAAJ,KAAoB;AACtC,QAAIN,iBAAiB,CAACd,WAAD,EAAcoB,KAAd,CAArB,EAA2CF,SAAS,CAACG,IAAV,CAAeD,KAAK,GAAG,CAAvB;AAC5C,GAFD;AAGA,SAAOF,SAAP;AACD,CANM;AAQP,OAAO,MAAMK,qBAAqB,GAAIvB,WAAD,IAAqC;AACxE,QAAMwB,kBAA4B,GAAG,EAArC;AACA,MAAIC,WAAW,GAAG,KAAlB;AACAzB,EAAAA,WAAW,CAACI,OAAZ,CAAoB,CAACM,IAAD,EAAOU,KAAP,KAAiB;AACnC,QAAIV,IAAI,CAAClB,KAAL,CAAW,CAAX,EAAc,CAAd,MAAqB,KAAzB,EAAgCiC,WAAW,GAAG,CAACA,WAAf;AAChC,QAAI,CAACf,IAAI,KAAK,IAAT,IAAiBA,IAAI,KAAK,QAA3B,KAAwCe,WAA5C,EAAyDD,kBAAkB,CAACH,IAAnB,CAAwBD,KAAxB;AAC1D,GAHD;AAKA,SAAOI,kBAAP;AACD,CATM;AAWP,OAAO,MAAME,sBAAsB,GAAI1B,WAAD,IAAqC;AACzE,QAAM2B,mBAA6B,GAAG,EAAtC;AACA3B,EAAAA,WAAW,CAACI,OAAZ,CAAoB,CAACM,IAAD,EAAOU,KAAP,KAAiB;AACnC,QAAIA,KAAK,KAAK,CAAV,IAAeV,IAAI,CAAClB,KAAL,CAAW,CAAX,EAAc,CAAd,MAAqB,GAApC,IAA2CF,WAAW,CAACU,WAAW,CAACoB,KAAK,GAAG,CAAT,CAAZ,CAAX,KAAwC,GAAvF,EACEO,mBAAmB,CAACN,IAApB,CAAyBD,KAAzB;AACH,GAHD;AAIA,SAAOO,mBAAP;AACD,CAPM","sourcesContent":["const blankList = ['\\\\', '', '&nbsp;'];\n\nexport const getLastText = (input: string): string => {\n  return input.slice(input.length - 1, input.length);\n};\n\nexport const isEmptyLine = (input: string): boolean => {\n  return input === '';\n};\n\nexport const hideLastSlash = (input: string): string => {\n  return `${input}&nbsp;`;\n};\n\nexport const createTextsByLine = (input: string): string[] => {\n  return input.split('\\n');\n};\n\nexport const applyBlankToMarkdown = (input: string): string => {\n  if (isEmptyLine(input)) return `\\\\`;\n  return input;\n};\n\nexport const changeText = (TextsByLine: string[], idxsToChange: number[], textToChange: string): string[] => {\n  const updatedTextsByLine = [...TextsByLine];\n  idxsToChange.forEach((idx) => {\n    updatedTextsByLine[idx] = textToChange;\n  });\n\n  return updatedTextsByLine;\n};\n\nexport const insertText = (TextsByLine: string[], idxsToChange: number[], textToInsert: string): string[] => {\n  let updatedTextsByLine = [...TextsByLine];\n  idxsToChange.forEach((idx) => {\n    updatedTextsByLine = [...updatedTextsByLine.slice(0, idx), textToInsert, ...updatedTextsByLine.slice(idx)];\n  });\n\n  return updatedTextsByLine;\n};\n\nexport const findLastTextIdx = (TextsByLine: string[]): number => {\n  let textIdx = -1;\n  TextsByLine.forEach((text, idx) => {\n    if (!blankList.includes(text)) textIdx = idx;\n  });\n  return textIdx;\n};\n\nexport const isBlankAfterLastText = (TextsByLine: string[], idx: number): boolean => {\n  const idxOfLastText = findLastTextIdx(TextsByLine);\n  if (idx > idxOfLastText && blankList.includes(TextsByLine[idx])) return true;\n  return false;\n};\n\nexport const isBlankBeforeText = (TextsByLine: string[], idx: number): boolean => {\n  const currentText = TextsByLine[idx];\n  const beforeText = TextsByLine[idx - 1];\n  if (!blankList.includes(currentText) && blankList.includes(beforeText)) return true;\n  return false;\n};\n\nexport const getBlankIdxsAfterLastText = (TextsByLine: string[]): number[] => {\n  const blankIdxs: number[] = [];\n  TextsByLine.forEach((_, index): void => {\n    if (isBlankAfterLastText(TextsByLine, index)) blankIdxs.push(index);\n  });\n  return blankIdxs;\n};\n\nexport const getBlankIdxsBeforeText = (TextsByLine: string[]): number[] => {\n  const blankIdxs: number[] = [];\n  TextsByLine.forEach((_, index): void => {\n    if (isBlankBeforeText(TextsByLine, index)) blankIdxs.push(index - 1);\n  });\n  return blankIdxs;\n};\n\nexport const getBlankIdxsInCodeBox = (TextsByLine: string[]): number[] => {\n  const idxsBlankInCodeBox: number[] = [];\n  let isInCodeBox = false;\n  TextsByLine.forEach((text, index) => {\n    if (text.slice(0, 3) === '```') isInCodeBox = !isInCodeBox;\n    if ((text === '\\\\' || text === '&nbsp;') && isInCodeBox) idxsBlankInCodeBox.push(index);\n  });\n\n  return idxsBlankInCodeBox;\n};\n\nexport const getBlankIdxsAfterTable = (TextsByLine: string[]): number[] => {\n  const idxsSlashAfterTable: number[] = [];\n  TextsByLine.forEach((text, index) => {\n    if (index !== 0 && text.slice(0, 1) !== '|' && getLastText(TextsByLine[index - 1]) === '|')\n      idxsSlashAfterTable.push(index);\n  });\n  return idxsSlashAfterTable;\n};\n"]},"metadata":{},"sourceType":"module"}