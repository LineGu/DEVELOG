{"ast":null,"code":"import _slicedToArray from \"/Users/hyungu/Desktop/front-dev/projects/develog/client/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nexport var findFrontOfLine = function findFrontOfLine(input, cursorPosition) {\n  var findingIndex = cursorPosition[0];\n  var isFindFront = true;\n\n  while (isFindFront) {\n    if (input[findingIndex - 1] === '\\n') {\n      isFindFront = false;\n      break;\n    }\n\n    if (findingIndex === 0) {\n      break;\n    }\n\n    findingIndex -= 1;\n  }\n\n  return findingIndex;\n};\n\nvar findLastOfLine = function findLastOfLine(input, cursorPosition) {\n  var isFindLast = true;\n  var lastIndex = 0;\n  var frontIndex = findFrontOfLine(input, cursorPosition);\n  var textTotalLength = input.length;\n\n  while (isFindLast) {\n    if (input[frontIndex] === '\\n') {\n      lastIndex = frontIndex;\n      isFindLast = false;\n      break;\n    }\n\n    if (frontIndex === textTotalLength) {\n      lastIndex = frontIndex;\n      isFindLast = false;\n      break;\n    }\n\n    frontIndex += 1;\n  }\n\n  return lastIndex;\n};\n\nvar insertTextFront = function insertTextFront(_ref) {\n  var input = _ref.input,\n      cursorPosition = _ref.cursorPosition,\n      insertText = _ref.insertText,\n      setInput = _ref.setInput;\n  var positionToInsert = findFrontOfLine(input, cursorPosition);\n  var textToCheckOverlap = input.slice(positionToInsert, positionToInsert + 4);\n  var cursorPositionToGo = [0, 0];\n  var beforeText = input.slice(0, positionToInsert);\n  var afterText = input.slice(positionToInsert);\n  var textToInsert = insertText;\n\n  if (insertText.includes('#') && textToCheckOverlap.includes('# ')) {\n    var indexOfMarkDownEnd = textToCheckOverlap.indexOf('# ') + 2;\n    afterText = afterText.slice(indexOfMarkDownEnd);\n  }\n\n  if (insertText.includes('>') && textToCheckOverlap.includes('> ')) {\n    var _indexOfMarkDownEnd = textToCheckOverlap.indexOf('> ') + 2;\n\n    textToInsert = '';\n    afterText = afterText.slice(_indexOfMarkDownEnd);\n  }\n\n  var newInput = beforeText + textToInsert + afterText;\n  setInput(newInput);\n  return newInput;\n};\n\nvar insertTextSide = function insertTextSide(_ref2) {\n  var input = _ref2.input,\n      cursorPosition = _ref2.cursorPosition,\n      insertText = _ref2.insertText,\n      setInput = _ref2.setInput;\n  var isSelected = cursorPosition[0] !== cursorPosition[1];\n  var textToInsert = insertText;\n  var cursorPositionToGo = [0, 0];\n\n  if (isSelected) {\n    var _cursorPosition = _slicedToArray(cursorPosition, 2),\n        startPosition = _cursorPosition[0],\n        endPosition = _cursorPosition[1];\n\n    var textSelected = input.slice(startPosition, endPosition);\n\n    var _beforeText = input.slice(0, startPosition);\n\n    var _afterText = input.slice(endPosition);\n\n    switch (textToInsert) {\n      case '**텍스트**':\n        if (_beforeText.slice(-2) === '**' && _afterText.slice(0, 2) === '**') {\n          _beforeText = _beforeText.slice(0, -2);\n          _afterText = _afterText.slice(2);\n          textToInsert = textSelected;\n          cursorPositionToGo = [startPosition - 2, endPosition - 2];\n          break;\n        }\n\n        if (textSelected.slice(0, 2) === '**' && textSelected.slice(-2) === '**') {\n          textToInsert = textSelected.slice(2, -2);\n          cursorPositionToGo = [startPosition, endPosition - 4];\n          break;\n        }\n\n        textToInsert = \"**\".concat(textSelected, \"**\");\n        cursorPositionToGo = [startPosition, endPosition + 4];\n        break;\n\n      case '_텍스트_':\n        if (_beforeText.slice(-1) === '_' && _afterText.slice(0, 1) === '_') {\n          _beforeText = _beforeText.slice(0, -1);\n          _afterText = _afterText.slice(1);\n          textToInsert = textSelected;\n          cursorPositionToGo = [startPosition - 1, endPosition - 1];\n          break;\n        }\n\n        if (isSelected && textSelected.slice(0, 1) === '_' && textSelected.slice(-1) === '_') {\n          textSelected = textSelected.slice(1, -1);\n          textToInsert = textSelected;\n          cursorPositionToGo = [startPosition, endPosition - 2];\n          break;\n        }\n\n        textToInsert = \"_\".concat(textSelected, \"_\");\n        cursorPositionToGo = [startPosition, endPosition + 2];\n        break;\n\n      case '[링크텍스트](링크)':\n        textToInsert = \"[\".concat(textSelected, \"](\\uB9C1\\uD06C)\");\n        cursorPositionToGo = [endPosition + 3, endPosition + 5];\n        break;\n\n      default:\n        break;\n    }\n\n    var _newInput = _beforeText + textToInsert + _afterText;\n\n    setInput(_newInput);\n    return cursorPositionToGo;\n  }\n\n  var positionToInsert = cursorPosition[0];\n  var beforeText = input.slice(0, positionToInsert);\n  var afterText = input.slice(positionToInsert);\n  var newInput = beforeText + textToInsert + afterText;\n\n  switch (textToInsert) {\n    case '**텍스트**':\n      cursorPositionToGo = [positionToInsert + 2, positionToInsert + 5];\n      break;\n\n    case '_텍스트_':\n      cursorPositionToGo = [positionToInsert + 1, positionToInsert + 4];\n      break;\n\n    case '[링크텍스트](링크)':\n      cursorPositionToGo = [positionToInsert + 1, positionToInsert + 6];\n      break;\n\n    default:\n      break;\n  }\n\n  setInput(newInput);\n  return cursorPositionToGo;\n};\n\nvar editInputText = function editInputText(_ref3) {\n  var event = _ref3.event,\n      input = _ref3.input,\n      setInput = _ref3.setInput,\n      cursorPosition = _ref3.cursorPosition;\n  var iconClicked = event.currentTarget.className.baseVal;\n  var cursorToGo = [0, 0];\n  var insertText = '';\n\n  switch (iconClicked) {\n    case 'h1':\n      insertText = '# ';\n      cursorToGo = insertTextFront({\n        input: input,\n        cursorPosition: cursorPosition,\n        insertText: insertText,\n        setInput: setInput\n      });\n      break;\n\n    case 'h2':\n      insertText = '## ';\n      cursorToGo = insertTextFront({\n        input: input,\n        cursorPosition: cursorPosition,\n        insertText: insertText,\n        setInput: setInput\n      });\n      break;\n\n    case 'h3':\n      insertText = '### ';\n      cursorToGo = insertTextFront({\n        input: input,\n        cursorPosition: cursorPosition,\n        insertText: insertText,\n        setInput: setInput\n      });\n      break;\n\n    case 'bold':\n      insertText = '**텍스트**';\n      cursorToGo = insertTextSide({\n        input: input,\n        cursorPosition: cursorPosition,\n        insertText: insertText,\n        setInput: setInput\n      });\n      break;\n\n    case 'italic':\n      insertText = '_텍스트_';\n      cursorToGo = insertTextSide({\n        input: input,\n        cursorPosition: cursorPosition,\n        insertText: insertText,\n        setInput: setInput\n      });\n      break;\n\n    case 'link':\n      insertText = '[링크텍스트](링크)';\n      cursorToGo = insertTextSide({\n        input: input,\n        cursorPosition: cursorPosition,\n        insertText: insertText,\n        setInput: setInput\n      });\n      break;\n\n    case 'quote':\n      insertText = '> ';\n      cursorToGo = insertTextFront({\n        input: input,\n        cursorPosition: cursorPosition,\n        insertText: insertText,\n        setInput: setInput\n      });\n      break;\n\n    default:\n      break;\n  }\n\n  return cursorToGo;\n};\n\nexport default editInputText;","map":{"version":3,"sources":["/Users/hyungu/Desktop/front-dev/projects/develog/client/src/utils/editInputText.ts"],"names":["findFrontOfLine","input","cursorPosition","findingIndex","isFindFront","findLastOfLine","isFindLast","lastIndex","frontIndex","textTotalLength","length","insertTextFront","insertText","setInput","positionToInsert","textToCheckOverlap","slice","cursorPositionToGo","beforeText","afterText","textToInsert","includes","indexOfMarkDownEnd","indexOf","newInput","insertTextSide","isSelected","startPosition","endPosition","textSelected","editInputText","event","iconClicked","currentTarget","className","baseVal","cursorToGo"],"mappings":";AA2BA,OAAO,IAAMA,eAAe,GAAG,SAAlBA,eAAkB,CAACC,KAAD,EAAgBC,cAAhB,EAAqD;AAClF,MAAIC,YAAY,GAAGD,cAAc,CAAC,CAAD,CAAjC;AACA,MAAIE,WAAW,GAAG,IAAlB;;AACA,SAAOA,WAAP,EAAoB;AAClB,QAAIH,KAAK,CAACE,YAAY,GAAG,CAAhB,CAAL,KAA4B,IAAhC,EAAsC;AACpCC,MAAAA,WAAW,GAAG,KAAd;AACA;AACD;;AACD,QAAID,YAAY,KAAK,CAArB,EAAwB;AACtB;AACD;;AACDA,IAAAA,YAAY,IAAI,CAAhB;AACD;;AACD,SAAOA,YAAP;AACD,CAdM;;AAgBP,IAAME,cAAc,GAAG,SAAjBA,cAAiB,CAACJ,KAAD,EAAgBC,cAAhB,EAAqD;AAC1E,MAAII,UAAU,GAAG,IAAjB;AACA,MAAIC,SAAS,GAAG,CAAhB;AACA,MAAIC,UAAU,GAAGR,eAAe,CAACC,KAAD,EAAQC,cAAR,CAAhC;AACA,MAAMO,eAAe,GAAGR,KAAK,CAACS,MAA9B;;AACA,SAAOJ,UAAP,EAAmB;AACjB,QAAIL,KAAK,CAACO,UAAD,CAAL,KAAsB,IAA1B,EAAgC;AAC9BD,MAAAA,SAAS,GAAGC,UAAZ;AACAF,MAAAA,UAAU,GAAG,KAAb;AACA;AACD;;AACD,QAAIE,UAAU,KAAKC,eAAnB,EAAoC;AAClCF,MAAAA,SAAS,GAAGC,UAAZ;AACAF,MAAAA,UAAU,GAAG,KAAb;AACA;AACD;;AACDE,IAAAA,UAAU,IAAI,CAAd;AACD;;AACD,SAAOD,SAAP;AACD,CAnBD;;AAqBA,IAAMI,eAAe,GAAG,SAAlBA,eAAkB,OAAkF;AAAA,MAA/EV,KAA+E,QAA/EA,KAA+E;AAAA,MAAxEC,cAAwE,QAAxEA,cAAwE;AAAA,MAAxDU,UAAwD,QAAxDA,UAAwD;AAAA,MAA5CC,QAA4C,QAA5CA,QAA4C;AACxG,MAAMC,gBAAgB,GAAGd,eAAe,CAACC,KAAD,EAAQC,cAAR,CAAxC;AACA,MAAMa,kBAAkB,GAAGd,KAAK,CAACe,KAAN,CAAYF,gBAAZ,EAA8BA,gBAAgB,GAAG,CAAjD,CAA3B;AACA,MAAMG,kBAAkB,GAAG,CAAC,CAAD,EAAI,CAAJ,CAA3B;AACA,MAAMC,UAAU,GAAGjB,KAAK,CAACe,KAAN,CAAY,CAAZ,EAAeF,gBAAf,CAAnB;AAEA,MAAIK,SAAS,GAAGlB,KAAK,CAACe,KAAN,CAAYF,gBAAZ,CAAhB;AACA,MAAIM,YAAY,GAAGR,UAAnB;;AAEA,MAAIA,UAAU,CAACS,QAAX,CAAoB,GAApB,KAA4BN,kBAAkB,CAACM,QAAnB,CAA4B,IAA5B,CAAhC,EAAmE;AACjE,QAAMC,kBAAkB,GAAGP,kBAAkB,CAACQ,OAAnB,CAA2B,IAA3B,IAAmC,CAA9D;AACAJ,IAAAA,SAAS,GAAGA,SAAS,CAACH,KAAV,CAAgBM,kBAAhB,CAAZ;AACD;;AACD,MAAIV,UAAU,CAACS,QAAX,CAAoB,GAApB,KAA4BN,kBAAkB,CAACM,QAAnB,CAA4B,IAA5B,CAAhC,EAAmE;AACjE,QAAMC,mBAAkB,GAAGP,kBAAkB,CAACQ,OAAnB,CAA2B,IAA3B,IAAmC,CAA9D;;AACAH,IAAAA,YAAY,GAAG,EAAf;AACAD,IAAAA,SAAS,GAAGA,SAAS,CAACH,KAAV,CAAgBM,mBAAhB,CAAZ;AACD;;AACD,MAAME,QAAQ,GAAGN,UAAU,GAAGE,YAAb,GAA4BD,SAA7C;AACAN,EAAAA,QAAQ,CAACW,QAAD,CAAR;AACA,SAAOA,QAAP;AACD,CArBD;;AAuBA,IAAMC,cAAc,GAAG,SAAjBA,cAAiB,QAAiF;AAAA,MAA9ExB,KAA8E,SAA9EA,KAA8E;AAAA,MAAvEC,cAAuE,SAAvEA,cAAuE;AAAA,MAAvDU,UAAuD,SAAvDA,UAAuD;AAAA,MAA3CC,QAA2C,SAA3CA,QAA2C;AACtG,MAAMa,UAAU,GAAGxB,cAAc,CAAC,CAAD,CAAd,KAAsBA,cAAc,CAAC,CAAD,CAAvD;AACA,MAAIkB,YAAY,GAAGR,UAAnB;AACA,MAAIK,kBAAkB,GAAG,CAAC,CAAD,EAAI,CAAJ,CAAzB;;AAEA,MAAIS,UAAJ,EAAgB;AAAA,yCACuBxB,cADvB;AAAA,QACPyB,aADO;AAAA,QACQC,WADR;;AAEd,QAAIC,YAAY,GAAG5B,KAAK,CAACe,KAAN,CAAYW,aAAZ,EAA2BC,WAA3B,CAAnB;;AACA,QAAIV,WAAU,GAAGjB,KAAK,CAACe,KAAN,CAAY,CAAZ,EAAeW,aAAf,CAAjB;;AACA,QAAIR,UAAS,GAAGlB,KAAK,CAACe,KAAN,CAAYY,WAAZ,CAAhB;;AAEA,YAAQR,YAAR;AACE,WAAK,SAAL;AACE,YAAIF,WAAU,CAACF,KAAX,CAAiB,CAAC,CAAlB,MAAyB,IAAzB,IAAiCG,UAAS,CAACH,KAAV,CAAgB,CAAhB,EAAmB,CAAnB,MAA0B,IAA/D,EAAqE;AACnEE,UAAAA,WAAU,GAAGA,WAAU,CAACF,KAAX,CAAiB,CAAjB,EAAoB,CAAC,CAArB,CAAb;AACAG,UAAAA,UAAS,GAAGA,UAAS,CAACH,KAAV,CAAgB,CAAhB,CAAZ;AACAI,UAAAA,YAAY,GAAGS,YAAf;AACAZ,UAAAA,kBAAkB,GAAG,CAACU,aAAa,GAAG,CAAjB,EAAoBC,WAAW,GAAG,CAAlC,CAArB;AACA;AACD;;AACD,YAAIC,YAAY,CAACb,KAAb,CAAmB,CAAnB,EAAsB,CAAtB,MAA6B,IAA7B,IAAqCa,YAAY,CAACb,KAAb,CAAmB,CAAC,CAApB,MAA2B,IAApE,EAA0E;AACxEI,UAAAA,YAAY,GAAGS,YAAY,CAACb,KAAb,CAAmB,CAAnB,EAAsB,CAAC,CAAvB,CAAf;AACAC,UAAAA,kBAAkB,GAAG,CAACU,aAAD,EAAgBC,WAAW,GAAG,CAA9B,CAArB;AACA;AACD;;AACDR,QAAAA,YAAY,eAAQS,YAAR,OAAZ;AACAZ,QAAAA,kBAAkB,GAAG,CAACU,aAAD,EAAgBC,WAAW,GAAG,CAA9B,CAArB;AACA;;AAEF,WAAK,OAAL;AACE,YAAIV,WAAU,CAACF,KAAX,CAAiB,CAAC,CAAlB,MAAyB,GAAzB,IAAgCG,UAAS,CAACH,KAAV,CAAgB,CAAhB,EAAmB,CAAnB,MAA0B,GAA9D,EAAmE;AACjEE,UAAAA,WAAU,GAAGA,WAAU,CAACF,KAAX,CAAiB,CAAjB,EAAoB,CAAC,CAArB,CAAb;AACAG,UAAAA,UAAS,GAAGA,UAAS,CAACH,KAAV,CAAgB,CAAhB,CAAZ;AACAI,UAAAA,YAAY,GAAGS,YAAf;AACAZ,UAAAA,kBAAkB,GAAG,CAACU,aAAa,GAAG,CAAjB,EAAoBC,WAAW,GAAG,CAAlC,CAArB;AACA;AACD;;AACD,YAAIF,UAAU,IAAIG,YAAY,CAACb,KAAb,CAAmB,CAAnB,EAAsB,CAAtB,MAA6B,GAA3C,IAAkDa,YAAY,CAACb,KAAb,CAAmB,CAAC,CAApB,MAA2B,GAAjF,EAAsF;AACpFa,UAAAA,YAAY,GAAGA,YAAY,CAACb,KAAb,CAAmB,CAAnB,EAAsB,CAAC,CAAvB,CAAf;AACAI,UAAAA,YAAY,GAAGS,YAAf;AACAZ,UAAAA,kBAAkB,GAAG,CAACU,aAAD,EAAgBC,WAAW,GAAG,CAA9B,CAArB;AACA;AACD;;AACDR,QAAAA,YAAY,cAAOS,YAAP,MAAZ;AACAZ,QAAAA,kBAAkB,GAAG,CAACU,aAAD,EAAgBC,WAAW,GAAG,CAA9B,CAArB;AACA;;AAEF,WAAK,aAAL;AACER,QAAAA,YAAY,cAAOS,YAAP,oBAAZ;AACAZ,QAAAA,kBAAkB,GAAG,CAACW,WAAW,GAAG,CAAf,EAAkBA,WAAW,GAAG,CAAhC,CAArB;AACA;;AAEF;AACE;AA1CJ;;AA4CA,QAAMJ,SAAQ,GAAGN,WAAU,GAAGE,YAAb,GAA4BD,UAA7C;;AAEAN,IAAAA,QAAQ,CAACW,SAAD,CAAR;AACA,WAAOP,kBAAP;AACD;;AAED,MAAMH,gBAAgB,GAAGZ,cAAc,CAAC,CAAD,CAAvC;AACA,MAAMgB,UAAU,GAAGjB,KAAK,CAACe,KAAN,CAAY,CAAZ,EAAeF,gBAAf,CAAnB;AACA,MAAMK,SAAS,GAAGlB,KAAK,CAACe,KAAN,CAAYF,gBAAZ,CAAlB;AACA,MAAMU,QAAQ,GAAGN,UAAU,GAAGE,YAAb,GAA4BD,SAA7C;;AACA,UAAQC,YAAR;AACE,SAAK,SAAL;AACEH,MAAAA,kBAAkB,GAAG,CAACH,gBAAgB,GAAG,CAApB,EAAuBA,gBAAgB,GAAG,CAA1C,CAArB;AACA;;AACF,SAAK,OAAL;AACEG,MAAAA,kBAAkB,GAAG,CAACH,gBAAgB,GAAG,CAApB,EAAuBA,gBAAgB,GAAG,CAA1C,CAArB;AACA;;AACF,SAAK,aAAL;AACEG,MAAAA,kBAAkB,GAAG,CAACH,gBAAgB,GAAG,CAApB,EAAuBA,gBAAgB,GAAG,CAA1C,CAArB;AACA;;AACF;AACE;AAXJ;;AAaAD,EAAAA,QAAQ,CAACW,QAAD,CAAR;AACA,SAAOP,kBAAP;AACD,CAhFD;;AAkFA,IAAMa,aAAa,GAAG,SAAhBA,aAAgB,QAA0E;AAAA,MAAvEC,KAAuE,SAAvEA,KAAuE;AAAA,MAAhE9B,KAAgE,SAAhEA,KAAgE;AAAA,MAAzDY,QAAyD,SAAzDA,QAAyD;AAAA,MAA/CX,cAA+C,SAA/CA,cAA+C;AAC9F,MAAM8B,WAAW,GAAGD,KAAK,CAACE,aAAN,CAAoBC,SAApB,CAA8BC,OAAlD;AAEA,MAAIC,UAAoB,GAAG,CAAC,CAAD,EAAI,CAAJ,CAA3B;AAEA,MAAIxB,UAAU,GAAG,EAAjB;;AACA,UAAQoB,WAAR;AACE,SAAK,IAAL;AACEpB,MAAAA,UAAU,GAAG,IAAb;AACAwB,MAAAA,UAAU,GAAGzB,eAAe,CAAC;AAAEV,QAAAA,KAAK,EAALA,KAAF;AAASC,QAAAA,cAAc,EAAdA,cAAT;AAAyBU,QAAAA,UAAU,EAAVA,UAAzB;AAAqCC,QAAAA,QAAQ,EAARA;AAArC,OAAD,CAA5B;AACA;;AAEF,SAAK,IAAL;AACED,MAAAA,UAAU,GAAG,KAAb;AACAwB,MAAAA,UAAU,GAAGzB,eAAe,CAAC;AAAEV,QAAAA,KAAK,EAALA,KAAF;AAASC,QAAAA,cAAc,EAAdA,cAAT;AAAyBU,QAAAA,UAAU,EAAVA,UAAzB;AAAqCC,QAAAA,QAAQ,EAARA;AAArC,OAAD,CAA5B;AACA;;AAEF,SAAK,IAAL;AACED,MAAAA,UAAU,GAAG,MAAb;AACAwB,MAAAA,UAAU,GAAGzB,eAAe,CAAC;AAAEV,QAAAA,KAAK,EAALA,KAAF;AAASC,QAAAA,cAAc,EAAdA,cAAT;AAAyBU,QAAAA,UAAU,EAAVA,UAAzB;AAAqCC,QAAAA,QAAQ,EAARA;AAArC,OAAD,CAA5B;AACA;;AAEF,SAAK,MAAL;AACED,MAAAA,UAAU,GAAG,SAAb;AACAwB,MAAAA,UAAU,GAAGX,cAAc,CAAC;AAAExB,QAAAA,KAAK,EAALA,KAAF;AAASC,QAAAA,cAAc,EAAdA,cAAT;AAAyBU,QAAAA,UAAU,EAAVA,UAAzB;AAAqCC,QAAAA,QAAQ,EAARA;AAArC,OAAD,CAA3B;AACA;;AAEF,SAAK,QAAL;AACED,MAAAA,UAAU,GAAG,OAAb;AACAwB,MAAAA,UAAU,GAAGX,cAAc,CAAC;AAAExB,QAAAA,KAAK,EAALA,KAAF;AAASC,QAAAA,cAAc,EAAdA,cAAT;AAAyBU,QAAAA,UAAU,EAAVA,UAAzB;AAAqCC,QAAAA,QAAQ,EAARA;AAArC,OAAD,CAA3B;AACA;;AAEF,SAAK,MAAL;AACED,MAAAA,UAAU,GAAG,aAAb;AACAwB,MAAAA,UAAU,GAAGX,cAAc,CAAC;AAAExB,QAAAA,KAAK,EAALA,KAAF;AAASC,QAAAA,cAAc,EAAdA,cAAT;AAAyBU,QAAAA,UAAU,EAAVA,UAAzB;AAAqCC,QAAAA,QAAQ,EAARA;AAArC,OAAD,CAA3B;AACA;;AAEF,SAAK,OAAL;AACED,MAAAA,UAAU,GAAG,IAAb;AACAwB,MAAAA,UAAU,GAAGzB,eAAe,CAAC;AAAEV,QAAAA,KAAK,EAALA,KAAF;AAASC,QAAAA,cAAc,EAAdA,cAAT;AAAyBU,QAAAA,UAAU,EAAVA,UAAzB;AAAqCC,QAAAA,QAAQ,EAARA;AAArC,OAAD,CAA5B;AACA;;AAEF;AACE;AArCJ;;AAuCA,SAAOuB,UAAP;AACD,CA9CD;;AAgDA,eAAeN,aAAf","sourcesContent":["import { Dispatch, SetStateAction } from 'react';\n\ninterface IEditTextProps {\n  event: React.MouseEvent<SVGElement, MouseEvent>;\n  input: string;\n  setInput: Dispatch<SetStateAction<string>>;\n  cursorPosition: number[];\n}\n\ninterface IInsertFrontProps {\n  input: string;\n  cursorPosition: number[];\n  insertText: string;\n  setInput: Dispatch<SetStateAction<string>>;\n}\n\ninterface IInsertSideProps {\n  input: string;\n  cursorPosition: number[];\n  insertText: string;\n  setInput: Dispatch<SetStateAction<string>>;\n}\n\ninterface IInsertControlProps extends IInsertFrontProps {\n  setInput: Dispatch<SetStateAction<string>>;\n}\n\nexport const findFrontOfLine = (input: string, cursorPosition: number[]): number => {\n  let findingIndex = cursorPosition[0];\n  let isFindFront = true;\n  while (isFindFront) {\n    if (input[findingIndex - 1] === '\\n') {\n      isFindFront = false;\n      break;\n    }\n    if (findingIndex === 0) {\n      break;\n    }\n    findingIndex -= 1;\n  }\n  return findingIndex;\n};\n\nconst findLastOfLine = (input: string, cursorPosition: number[]): number => {\n  let isFindLast = true;\n  let lastIndex = 0;\n  let frontIndex = findFrontOfLine(input, cursorPosition);\n  const textTotalLength = input.length;\n  while (isFindLast) {\n    if (input[frontIndex] === '\\n') {\n      lastIndex = frontIndex;\n      isFindLast = false;\n      break;\n    }\n    if (frontIndex === textTotalLength) {\n      lastIndex = frontIndex;\n      isFindLast = false;\n      break;\n    }\n    frontIndex += 1;\n  }\n  return lastIndex;\n};\n\nconst insertTextFront = ({ input, cursorPosition, insertText, setInput }: IInsertFrontProps): number[] => {\n  const positionToInsert = findFrontOfLine(input, cursorPosition);\n  const textToCheckOverlap = input.slice(positionToInsert, positionToInsert + 4);\n  const cursorPositionToGo = [0, 0];\n  const beforeText = input.slice(0, positionToInsert);\n\n  let afterText = input.slice(positionToInsert);\n  let textToInsert = insertText;\n\n  if (insertText.includes('#') && textToCheckOverlap.includes('# ')) {\n    const indexOfMarkDownEnd = textToCheckOverlap.indexOf('# ') + 2;\n    afterText = afterText.slice(indexOfMarkDownEnd);\n  }\n  if (insertText.includes('>') && textToCheckOverlap.includes('> ')) {\n    const indexOfMarkDownEnd = textToCheckOverlap.indexOf('> ') + 2;\n    textToInsert = '';\n    afterText = afterText.slice(indexOfMarkDownEnd);\n  }\n  const newInput = beforeText + textToInsert + afterText;\n  setInput(newInput);\n  return newInput;\n};\n\nconst insertTextSide = ({ input, cursorPosition, insertText, setInput }: IInsertSideProps): number[] => {\n  const isSelected = cursorPosition[0] !== cursorPosition[1];\n  let textToInsert = insertText;\n  let cursorPositionToGo = [0, 0];\n\n  if (isSelected) {\n    const [startPosition, endPosition] = cursorPosition;\n    let textSelected = input.slice(startPosition, endPosition);\n    let beforeText = input.slice(0, startPosition);\n    let afterText = input.slice(endPosition);\n\n    switch (textToInsert) {\n      case '**텍스트**':\n        if (beforeText.slice(-2) === '**' && afterText.slice(0, 2) === '**') {\n          beforeText = beforeText.slice(0, -2);\n          afterText = afterText.slice(2);\n          textToInsert = textSelected;\n          cursorPositionToGo = [startPosition - 2, endPosition - 2];\n          break;\n        }\n        if (textSelected.slice(0, 2) === '**' && textSelected.slice(-2) === '**') {\n          textToInsert = textSelected.slice(2, -2);\n          cursorPositionToGo = [startPosition, endPosition - 4];\n          break;\n        }\n        textToInsert = `**${textSelected}**`;\n        cursorPositionToGo = [startPosition, endPosition + 4];\n        break;\n\n      case '_텍스트_':\n        if (beforeText.slice(-1) === '_' && afterText.slice(0, 1) === '_') {\n          beforeText = beforeText.slice(0, -1);\n          afterText = afterText.slice(1);\n          textToInsert = textSelected;\n          cursorPositionToGo = [startPosition - 1, endPosition - 1];\n          break;\n        }\n        if (isSelected && textSelected.slice(0, 1) === '_' && textSelected.slice(-1) === '_') {\n          textSelected = textSelected.slice(1, -1);\n          textToInsert = textSelected;\n          cursorPositionToGo = [startPosition, endPosition - 2];\n          break;\n        }\n        textToInsert = `_${textSelected}_`;\n        cursorPositionToGo = [startPosition, endPosition + 2];\n        break;\n\n      case '[링크텍스트](링크)':\n        textToInsert = `[${textSelected}](링크)`;\n        cursorPositionToGo = [endPosition + 3, endPosition + 5];\n        break;\n\n      default:\n        break;\n    }\n    const newInput = beforeText + textToInsert + afterText;\n\n    setInput(newInput);\n    return cursorPositionToGo;\n  }\n\n  const positionToInsert = cursorPosition[0];\n  const beforeText = input.slice(0, positionToInsert);\n  const afterText = input.slice(positionToInsert);\n  const newInput = beforeText + textToInsert + afterText;\n  switch (textToInsert) {\n    case '**텍스트**':\n      cursorPositionToGo = [positionToInsert + 2, positionToInsert + 5];\n      break;\n    case '_텍스트_':\n      cursorPositionToGo = [positionToInsert + 1, positionToInsert + 4];\n      break;\n    case '[링크텍스트](링크)':\n      cursorPositionToGo = [positionToInsert + 1, positionToInsert + 6];\n      break;\n    default:\n      break;\n  }\n  setInput(newInput);\n  return cursorPositionToGo;\n};\n\nconst editInputText = ({ event, input, setInput, cursorPosition }: IEditTextProps): number[] => {\n  const iconClicked = event.currentTarget.className.baseVal;\n\n  let cursorToGo: number[] = [0, 0];\n\n  let insertText = '';\n  switch (iconClicked) {\n    case 'h1':\n      insertText = '# ';\n      cursorToGo = insertTextFront({ input, cursorPosition, insertText, setInput });\n      break;\n\n    case 'h2':\n      insertText = '## ';\n      cursorToGo = insertTextFront({ input, cursorPosition, insertText, setInput });\n      break;\n\n    case 'h3':\n      insertText = '### ';\n      cursorToGo = insertTextFront({ input, cursorPosition, insertText, setInput });\n      break;\n\n    case 'bold':\n      insertText = '**텍스트**';\n      cursorToGo = insertTextSide({ input, cursorPosition, insertText, setInput });\n      break;\n\n    case 'italic':\n      insertText = '_텍스트_';\n      cursorToGo = insertTextSide({ input, cursorPosition, insertText, setInput });\n      break;\n\n    case 'link':\n      insertText = '[링크텍스트](링크)';\n      cursorToGo = insertTextSide({ input, cursorPosition, insertText, setInput });\n      break;\n\n    case 'quote':\n      insertText = '> ';\n      cursorToGo = insertTextFront({ input, cursorPosition, insertText, setInput });\n      break;\n\n    default:\n      break;\n  }\n  return cursorToGo;\n};\n\nexport default editInputText;\n"]},"metadata":{},"sourceType":"module"}