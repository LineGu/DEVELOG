{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport CurrentInsertion from './CurrentInsertion';\nexport default class AbstractTextEditor extends CurrentInsertion {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"pointStartText\", void 0);\n\n    _defineProperty(this, \"pointEndText\", void 0);\n\n    _defineProperty(this, \"onClickEditButton\", ({\n      input,\n      cursorPosition,\n      moveCursor\n    }) => {\n      const currentCursorIndex = cursorPosition[0];\n      const isSelected = cursorPosition[0] !== cursorPosition[1];\n      this.setIndexToInsert(currentCursorIndex);\n      this.setIndexToGo(currentCursorIndex);\n      let updatedInput = input;\n\n      if (isSelected) {\n        updatedInput = this.onClickSelectedText(input, cursorPosition, moveCursor);\n      }\n\n      const updatedText = this.insertText(input);\n      this.moveCursorAfterEdit(moveCursor);\n      return updatedText;\n    });\n\n    _defineProperty(this, \"onClickSelectedText\", ({\n      input,\n      cursorPosition,\n      moveCursor\n    }) => {\n      const [frontCursor, backCursor] = cursorPosition;\n      const selectText = input.slice(frontCursor, backCursor);\n      const isInSameTag = input.slice(frontCursor - this.pointStartText.length, frontCursor).includes(this.pointStartText) && input.slice(backCursor, backCursor + this.pointEndText.length).includes(this.pointEndText);\n      let updatedInput = input;\n\n      if (isInSameTag) {\n        updatedInput = input.slice(0, frontCursor - this.pointStartText.length) + selectText + input.slice(backCursor + this.pointStartText.length);\n        this.moveCursorAfterEdit(moveCursor);\n        return updatedInput;\n      }\n\n      updatedInput = input.slice(0, frontCursor) + this.pointStartText + selectText + this.pointEndText + input.slice(backCursor);\n      this.moveCursorAfterEdit(moveCursor);\n      return updatedInput;\n    });\n  }\n\n}","map":{"version":3,"sources":["/Users/hyungu/Desktop/front-dev/projects/develog/client/src/markdownController/ToolBarEditors/Abstract/TextEditor.ts"],"names":["CurrentInsertion","AbstractTextEditor","input","cursorPosition","moveCursor","currentCursorIndex","isSelected","setIndexToInsert","setIndexToGo","updatedInput","onClickSelectedText","updatedText","insertText","moveCursorAfterEdit","frontCursor","backCursor","selectText","slice","isInSameTag","pointStartText","length","includes","pointEndText"],"mappings":";;AACA,OAAOA,gBAAP,MAA6B,oBAA7B;AAEA,eAAe,MAAeC,kBAAf,SAA0CD,gBAA1C,CAA2D;AAAA;AAAA;;AAAA;;AAAA;;AAAA,+CAK7C,CAAC;AAAEE,MAAAA,KAAF;AAASC,MAAAA,cAAT;AAAyBC,MAAAA;AAAzB,KAAD,KAAuE;AAChG,YAAMC,kBAAkB,GAAGF,cAAc,CAAC,CAAD,CAAzC;AACA,YAAMG,UAAU,GAAGH,cAAc,CAAC,CAAD,CAAd,KAAsBA,cAAc,CAAC,CAAD,CAAvD;AACA,WAAKI,gBAAL,CAAsBF,kBAAtB;AACA,WAAKG,YAAL,CAAkBH,kBAAlB;AACA,UAAII,YAAY,GAAGP,KAAnB;;AACA,UAAII,UAAJ,EAAgB;AACdG,QAAAA,YAAY,GAAG,KAAKC,mBAAL,CAAyBR,KAAzB,EAAgCC,cAAhC,EAAgDC,UAAhD,CAAf;AACD;;AACD,YAAMO,WAAW,GAAG,KAAKC,UAAL,CAAgBV,KAAhB,CAApB;AACA,WAAKW,mBAAL,CAAyBT,UAAzB;AAEA,aAAOO,WAAP;AACD,KAlBuE;;AAAA,iDAoBxC,CAAC;AAAET,MAAAA,KAAF;AAASC,MAAAA,cAAT;AAAyBC,MAAAA;AAAzB,KAAD,KAAuE;AACrG,YAAM,CAACU,WAAD,EAAcC,UAAd,IAA4BZ,cAAlC;AACA,YAAMa,UAAU,GAAGd,KAAK,CAACe,KAAN,CAAYH,WAAZ,EAAyBC,UAAzB,CAAnB;AACA,YAAMG,WAAW,GACfhB,KAAK,CAACe,KAAN,CAAYH,WAAW,GAAG,KAAKK,cAAL,CAAoBC,MAA9C,EAAsDN,WAAtD,EAAmEO,QAAnE,CAA4E,KAAKF,cAAjF,KACAjB,KAAK,CAACe,KAAN,CAAYF,UAAZ,EAAwBA,UAAU,GAAG,KAAKO,YAAL,CAAkBF,MAAvD,EAA+DC,QAA/D,CAAwE,KAAKC,YAA7E,CAFF;AAIA,UAAIb,YAAY,GAAGP,KAAnB;;AACA,UAAIgB,WAAJ,EAAiB;AACfT,QAAAA,YAAY,GACVP,KAAK,CAACe,KAAN,CAAY,CAAZ,EAAeH,WAAW,GAAG,KAAKK,cAAL,CAAoBC,MAAjD,IACAJ,UADA,GAEAd,KAAK,CAACe,KAAN,CAAYF,UAAU,GAAG,KAAKI,cAAL,CAAoBC,MAA7C,CAHF;AAIA,aAAKP,mBAAL,CAAyBT,UAAzB;AACA,eAAOK,YAAP;AACD;;AACDA,MAAAA,YAAY,GACVP,KAAK,CAACe,KAAN,CAAY,CAAZ,EAAeH,WAAf,IAA8B,KAAKK,cAAnC,GAAoDH,UAApD,GAAiE,KAAKM,YAAtE,GAAqFpB,KAAK,CAACe,KAAN,CAAYF,UAAZ,CADvF;AAEA,WAAKF,mBAAL,CAAyBT,UAAzB;AACA,aAAOK,YAAP;AACD,KAxCuE;AAAA;;AAAA","sourcesContent":["import { IOnClickEditButton } from '@types';\nimport CurrentInsertion from './CurrentInsertion';\n\nexport default abstract class AbstractTextEditor extends CurrentInsertion {\n  protected abstract pointStartText: string;\n\n  protected abstract pointEndText: string;\n\n  public onClickEditButton = ({ input, cursorPosition, moveCursor }: IOnClickEditButton): string => {\n    const currentCursorIndex = cursorPosition[0];\n    const isSelected = cursorPosition[0] !== cursorPosition[1];\n    this.setIndexToInsert(currentCursorIndex);\n    this.setIndexToGo(currentCursorIndex);\n    let updatedInput = input;\n    if (isSelected) {\n      updatedInput = this.onClickSelectedText(input, cursorPosition, moveCursor);\n    }\n    const updatedText = this.insertText(input);\n    this.moveCursorAfterEdit(moveCursor);\n\n    return updatedText;\n  };\n\n  protected onClickSelectedText = ({ input, cursorPosition, moveCursor }: IOnClickEditButton): string => {\n    const [frontCursor, backCursor] = cursorPosition;\n    const selectText = input.slice(frontCursor, backCursor);\n    const isInSameTag =\n      input.slice(frontCursor - this.pointStartText.length, frontCursor).includes(this.pointStartText) &&\n      input.slice(backCursor, backCursor + this.pointEndText.length).includes(this.pointEndText);\n\n    let updatedInput = input;\n    if (isInSameTag) {\n      updatedInput =\n        input.slice(0, frontCursor - this.pointStartText.length) +\n        selectText +\n        input.slice(backCursor + this.pointStartText.length);\n      this.moveCursorAfterEdit(moveCursor);\n      return updatedInput;\n    }\n    updatedInput =\n      input.slice(0, frontCursor) + this.pointStartText + selectText + this.pointEndText + input.slice(backCursor);\n    this.moveCursorAfterEdit(moveCursor);\n    return updatedInput;\n  };\n}\n"]},"metadata":{},"sourceType":"module"}